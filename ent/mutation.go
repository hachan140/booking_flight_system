// Code generated by ent, DO NOT EDIT.

package ent

import (
	"booking-flight-sytem/ent/airport"
	"booking-flight-sytem/ent/booking"
	"booking-flight-sytem/ent/customer"
	"booking-flight-sytem/ent/flight"
	"booking-flight-sytem/ent/member"
	"booking-flight-sytem/ent/plane"
	"booking-flight-sytem/ent/predicate"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAirport  = "Airport"
	TypeBooking  = "Booking"
	TypeCustomer = "Customer"
	TypeFlight   = "Flight"
	TypeMember   = "Member"
	TypePlane    = "Plane"
)

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	created_at             *time.Time
	updated_at             *time.Time
	name                   *string
	lat                    *float64
	addlat                 *float64
	long                   *float64
	addlong                *float64
	clearedFields          map[string]struct{}
	from_airport_id        map[int]struct{}
	removedfrom_airport_id map[int]struct{}
	clearedfrom_airport_id bool
	dest_airport_id        map[int]struct{}
	removeddest_airport_id map[int]struct{}
	cleareddest_airport_id bool
	done                   bool
	oldValue               func(context.Context) (*Airport, error)
	predicates             []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id int) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AirportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AirportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AirportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AirportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AirportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AirportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetLat sets the "lat" field.
func (m *AirportMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *AirportMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *AirportMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *AirportMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *AirportMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetLong sets the "long" field.
func (m *AirportMutation) SetLong(f float64) {
	m.long = &f
	m.addlong = nil
}

// Long returns the value of the "long" field in the mutation.
func (m *AirportMutation) Long() (r float64, exists bool) {
	v := m.long
	if v == nil {
		return
	}
	return *v, true
}

// OldLong returns the old "long" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLong(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLong: %w", err)
	}
	return oldValue.Long, nil
}

// AddLong adds f to the "long" field.
func (m *AirportMutation) AddLong(f float64) {
	if m.addlong != nil {
		*m.addlong += f
	} else {
		m.addlong = &f
	}
}

// AddedLong returns the value that was added to the "long" field in this mutation.
func (m *AirportMutation) AddedLong() (r float64, exists bool) {
	v := m.addlong
	if v == nil {
		return
	}
	return *v, true
}

// ResetLong resets all changes to the "long" field.
func (m *AirportMutation) ResetLong() {
	m.long = nil
	m.addlong = nil
}

// AddFromAirportIDIDs adds the "from_airport_id" edge to the Flight entity by ids.
func (m *AirportMutation) AddFromAirportIDIDs(ids ...int) {
	if m.from_airport_id == nil {
		m.from_airport_id = make(map[int]struct{})
	}
	for i := range ids {
		m.from_airport_id[ids[i]] = struct{}{}
	}
}

// ClearFromAirportID clears the "from_airport_id" edge to the Flight entity.
func (m *AirportMutation) ClearFromAirportID() {
	m.clearedfrom_airport_id = true
}

// FromAirportIDCleared reports if the "from_airport_id" edge to the Flight entity was cleared.
func (m *AirportMutation) FromAirportIDCleared() bool {
	return m.clearedfrom_airport_id
}

// RemoveFromAirportIDIDs removes the "from_airport_id" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveFromAirportIDIDs(ids ...int) {
	if m.removedfrom_airport_id == nil {
		m.removedfrom_airport_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.from_airport_id, ids[i])
		m.removedfrom_airport_id[ids[i]] = struct{}{}
	}
}

// RemovedFromAirportID returns the removed IDs of the "from_airport_id" edge to the Flight entity.
func (m *AirportMutation) RemovedFromAirportIDIDs() (ids []int) {
	for id := range m.removedfrom_airport_id {
		ids = append(ids, id)
	}
	return
}

// FromAirportIDIDs returns the "from_airport_id" edge IDs in the mutation.
func (m *AirportMutation) FromAirportIDIDs() (ids []int) {
	for id := range m.from_airport_id {
		ids = append(ids, id)
	}
	return
}

// ResetFromAirportID resets all changes to the "from_airport_id" edge.
func (m *AirportMutation) ResetFromAirportID() {
	m.from_airport_id = nil
	m.clearedfrom_airport_id = false
	m.removedfrom_airport_id = nil
}

// AddDestAirportIDIDs adds the "dest_airport_id" edge to the Flight entity by ids.
func (m *AirportMutation) AddDestAirportIDIDs(ids ...int) {
	if m.dest_airport_id == nil {
		m.dest_airport_id = make(map[int]struct{})
	}
	for i := range ids {
		m.dest_airport_id[ids[i]] = struct{}{}
	}
}

// ClearDestAirportID clears the "dest_airport_id" edge to the Flight entity.
func (m *AirportMutation) ClearDestAirportID() {
	m.cleareddest_airport_id = true
}

// DestAirportIDCleared reports if the "dest_airport_id" edge to the Flight entity was cleared.
func (m *AirportMutation) DestAirportIDCleared() bool {
	return m.cleareddest_airport_id
}

// RemoveDestAirportIDIDs removes the "dest_airport_id" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveDestAirportIDIDs(ids ...int) {
	if m.removeddest_airport_id == nil {
		m.removeddest_airport_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.dest_airport_id, ids[i])
		m.removeddest_airport_id[ids[i]] = struct{}{}
	}
}

// RemovedDestAirportID returns the removed IDs of the "dest_airport_id" edge to the Flight entity.
func (m *AirportMutation) RemovedDestAirportIDIDs() (ids []int) {
	for id := range m.removeddest_airport_id {
		ids = append(ids, id)
	}
	return
}

// DestAirportIDIDs returns the "dest_airport_id" edge IDs in the mutation.
func (m *AirportMutation) DestAirportIDIDs() (ids []int) {
	for id := range m.dest_airport_id {
		ids = append(ids, id)
	}
	return
}

// ResetDestAirportID resets all changes to the "dest_airport_id" edge.
func (m *AirportMutation) ResetDestAirportID() {
	m.dest_airport_id = nil
	m.cleareddest_airport_id = false
	m.removeddest_airport_id = nil
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AirportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AirportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Airport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AirportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, airport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, airport.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.lat != nil {
		fields = append(fields, airport.FieldLat)
	}
	if m.long != nil {
		fields = append(fields, airport.FieldLong)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldCreatedAt:
		return m.CreatedAt()
	case airport.FieldUpdatedAt:
		return m.UpdatedAt()
	case airport.FieldName:
		return m.Name()
	case airport.FieldLat:
		return m.Lat()
	case airport.FieldLong:
		return m.Long()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case airport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldLat:
		return m.OldLat(ctx)
	case airport.FieldLong:
		return m.OldLong(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case airport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case airport.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLong(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	var fields []string
	if m.addlat != nil {
		fields = append(fields, airport.FieldLat)
	}
	if m.addlong != nil {
		fields = append(fields, airport.FieldLong)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldLat:
		return m.AddedLat()
	case airport.FieldLong:
		return m.AddedLong()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case airport.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case airport.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLong(v)
		return nil
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case airport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldLat:
		m.ResetLat()
		return nil
	case airport.FieldLong:
		m.ResetLong()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_airport_id != nil {
		edges = append(edges, airport.EdgeFromAirportID)
	}
	if m.dest_airport_id != nil {
		edges = append(edges, airport.EdgeDestAirportID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeFromAirportID:
		ids := make([]ent.Value, 0, len(m.from_airport_id))
		for id := range m.from_airport_id {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeDestAirportID:
		ids := make([]ent.Value, 0, len(m.dest_airport_id))
		for id := range m.dest_airport_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfrom_airport_id != nil {
		edges = append(edges, airport.EdgeFromAirportID)
	}
	if m.removeddest_airport_id != nil {
		edges = append(edges, airport.EdgeDestAirportID)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeFromAirportID:
		ids := make([]ent.Value, 0, len(m.removedfrom_airport_id))
		for id := range m.removedfrom_airport_id {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeDestAirportID:
		ids := make([]ent.Value, 0, len(m.removeddest_airport_id))
		for id := range m.removeddest_airport_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_airport_id {
		edges = append(edges, airport.EdgeFromAirportID)
	}
	if m.cleareddest_airport_id {
		edges = append(edges, airport.EdgeDestAirportID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeFromAirportID:
		return m.clearedfrom_airport_id
	case airport.EdgeDestAirportID:
		return m.cleareddest_airport_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeFromAirportID:
		m.ResetFromAirportID()
		return nil
	case airport.EdgeDestAirportID:
		m.ResetDestAirportID()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	created_at    *time.Time
	updated_at    *time.Time
	code          *string
	status        *booking.Status
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Booking, error)
	predicates    []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id int) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *BookingMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BookingMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *BookingMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(b booking.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r booking.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v booking.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, booking.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, booking.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, booking.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldCreatedAt:
		return m.CreatedAt()
	case booking.FieldUpdatedAt:
		return m.UpdatedAt()
	case booking.FieldCode:
		return m.Code()
	case booking.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case booking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case booking.FieldCode:
		return m.OldCode(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case booking.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case booking.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(booking.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case booking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case booking.FieldCode:
		m.ResetCode()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Booking edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	email              *string
	phone_number       *string
	full_name          *string
	dob                *time.Time
	cid                *string
	clearedFields      map[string]struct{}
	customer_id        map[int]struct{}
	removedcustomer_id map[int]struct{}
	clearedcustomer_id bool
	done               bool
	oldValue           func(context.Context) (*Customer, error)
	predicates         []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *CustomerMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *CustomerMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *CustomerMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetFullName sets the "full_name" field.
func (m *CustomerMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *CustomerMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *CustomerMutation) ResetFullName() {
	m.full_name = nil
}

// SetDob sets the "dob" field.
func (m *CustomerMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *CustomerMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ResetDob resets all changes to the "dob" field.
func (m *CustomerMutation) ResetDob() {
	m.dob = nil
}

// SetCid sets the "cid" field.
func (m *CustomerMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the value of the "cid" field in the mutation.
func (m *CustomerMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *CustomerMutation) ResetCid() {
	m.cid = nil
}

// AddCustomerIDIDs adds the "customer_id" edge to the Booking entity by ids.
func (m *CustomerMutation) AddCustomerIDIDs(ids ...int) {
	if m.customer_id == nil {
		m.customer_id = make(map[int]struct{})
	}
	for i := range ids {
		m.customer_id[ids[i]] = struct{}{}
	}
}

// ClearCustomerID clears the "customer_id" edge to the Booking entity.
func (m *CustomerMutation) ClearCustomerID() {
	m.clearedcustomer_id = true
}

// CustomerIDCleared reports if the "customer_id" edge to the Booking entity was cleared.
func (m *CustomerMutation) CustomerIDCleared() bool {
	return m.clearedcustomer_id
}

// RemoveCustomerIDIDs removes the "customer_id" edge to the Booking entity by IDs.
func (m *CustomerMutation) RemoveCustomerIDIDs(ids ...int) {
	if m.removedcustomer_id == nil {
		m.removedcustomer_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.customer_id, ids[i])
		m.removedcustomer_id[ids[i]] = struct{}{}
	}
}

// RemovedCustomerID returns the removed IDs of the "customer_id" edge to the Booking entity.
func (m *CustomerMutation) RemovedCustomerIDIDs() (ids []int) {
	for id := range m.removedcustomer_id {
		ids = append(ids, id)
	}
	return
}

// CustomerIDIDs returns the "customer_id" edge IDs in the mutation.
func (m *CustomerMutation) CustomerIDIDs() (ids []int) {
	for id := range m.customer_id {
		ids = append(ids, id)
	}
	return
}

// ResetCustomerID resets all changes to the "customer_id" edge.
func (m *CustomerMutation) ResetCustomerID() {
	m.customer_id = nil
	m.clearedcustomer_id = false
	m.removedcustomer_id = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, customer.FieldPhoneNumber)
	}
	if m.full_name != nil {
		fields = append(fields, customer.FieldFullName)
	}
	if m.dob != nil {
		fields = append(fields, customer.FieldDob)
	}
	if m.cid != nil {
		fields = append(fields, customer.FieldCid)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldPhoneNumber:
		return m.PhoneNumber()
	case customer.FieldFullName:
		return m.FullName()
	case customer.FieldDob:
		return m.Dob()
	case customer.FieldCid:
		return m.Cid()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case customer.FieldFullName:
		return m.OldFullName(ctx)
	case customer.FieldDob:
		return m.OldDob(ctx)
	case customer.FieldCid:
		return m.OldCid(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case customer.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case customer.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case customer.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case customer.FieldFullName:
		m.ResetFullName()
		return nil
	case customer.FieldDob:
		m.ResetDob()
		return nil
	case customer.FieldCid:
		m.ResetCid()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.customer_id != nil {
		edges = append(edges, customer.EdgeCustomerID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeCustomerID:
		ids := make([]ent.Value, 0, len(m.customer_id))
		for id := range m.customer_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcustomer_id != nil {
		edges = append(edges, customer.EdgeCustomerID)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeCustomerID:
		ids := make([]ent.Value, 0, len(m.removedcustomer_id))
		for id := range m.removedcustomer_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcustomer_id {
		edges = append(edges, customer.EdgeCustomerID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeCustomerID:
		return m.clearedcustomer_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeCustomerID:
		m.ResetCustomerID()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// FlightMutation represents an operation that mutates the Flight nodes in the graph.
type FlightMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	depart_at            *time.Time
	land_at              *time.Time
	available_ec_slot    *int
	addavailable_ec_slot *int
	available_bc_slot    *int
	addavailable_bc_slot *int
	status               *flight.Status
	clearedFields        map[string]struct{}
	flight_id            map[int]struct{}
	removedflight_id     map[int]struct{}
	clearedflight_id     bool
	done                 bool
	oldValue             func(context.Context) (*Flight, error)
	predicates           []predicate.Flight
}

var _ ent.Mutation = (*FlightMutation)(nil)

// flightOption allows management of the mutation configuration using functional options.
type flightOption func(*FlightMutation)

// newFlightMutation creates new mutation for the Flight entity.
func newFlightMutation(c config, op Op, opts ...flightOption) *FlightMutation {
	m := &FlightMutation{
		config:        c,
		op:            op,
		typ:           TypeFlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightID sets the ID field of the mutation.
func withFlightID(id int) flightOption {
	return func(m *FlightMutation) {
		var (
			err   error
			once  sync.Once
			value *Flight
		)
		m.oldValue = func(ctx context.Context) (*Flight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Flight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlight sets the old Flight of the mutation.
func withFlight(node *Flight) flightOption {
	return func(m *FlightMutation) {
		m.oldValue = func(context.Context) (*Flight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Flight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FlightMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FlightMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FlightMutation) ResetName() {
	m.name = nil
}

// SetDepartAt sets the "depart_at" field.
func (m *FlightMutation) SetDepartAt(t time.Time) {
	m.depart_at = &t
}

// DepartAt returns the value of the "depart_at" field in the mutation.
func (m *FlightMutation) DepartAt() (r time.Time, exists bool) {
	v := m.depart_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartAt returns the old "depart_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldDepartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartAt: %w", err)
	}
	return oldValue.DepartAt, nil
}

// ResetDepartAt resets all changes to the "depart_at" field.
func (m *FlightMutation) ResetDepartAt() {
	m.depart_at = nil
}

// SetLandAt sets the "land_at" field.
func (m *FlightMutation) SetLandAt(t time.Time) {
	m.land_at = &t
}

// LandAt returns the value of the "land_at" field in the mutation.
func (m *FlightMutation) LandAt() (r time.Time, exists bool) {
	v := m.land_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLandAt returns the old "land_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldLandAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandAt: %w", err)
	}
	return oldValue.LandAt, nil
}

// ResetLandAt resets all changes to the "land_at" field.
func (m *FlightMutation) ResetLandAt() {
	m.land_at = nil
}

// SetAvailableEcSlot sets the "available_ec_slot" field.
func (m *FlightMutation) SetAvailableEcSlot(i int) {
	m.available_ec_slot = &i
	m.addavailable_ec_slot = nil
}

// AvailableEcSlot returns the value of the "available_ec_slot" field in the mutation.
func (m *FlightMutation) AvailableEcSlot() (r int, exists bool) {
	v := m.available_ec_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableEcSlot returns the old "available_ec_slot" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldAvailableEcSlot(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableEcSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableEcSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableEcSlot: %w", err)
	}
	return oldValue.AvailableEcSlot, nil
}

// AddAvailableEcSlot adds i to the "available_ec_slot" field.
func (m *FlightMutation) AddAvailableEcSlot(i int) {
	if m.addavailable_ec_slot != nil {
		*m.addavailable_ec_slot += i
	} else {
		m.addavailable_ec_slot = &i
	}
}

// AddedAvailableEcSlot returns the value that was added to the "available_ec_slot" field in this mutation.
func (m *FlightMutation) AddedAvailableEcSlot() (r int, exists bool) {
	v := m.addavailable_ec_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableEcSlot resets all changes to the "available_ec_slot" field.
func (m *FlightMutation) ResetAvailableEcSlot() {
	m.available_ec_slot = nil
	m.addavailable_ec_slot = nil
}

// SetAvailableBcSlot sets the "available_bc_slot" field.
func (m *FlightMutation) SetAvailableBcSlot(i int) {
	m.available_bc_slot = &i
	m.addavailable_bc_slot = nil
}

// AvailableBcSlot returns the value of the "available_bc_slot" field in the mutation.
func (m *FlightMutation) AvailableBcSlot() (r int, exists bool) {
	v := m.available_bc_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableBcSlot returns the old "available_bc_slot" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldAvailableBcSlot(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableBcSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableBcSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableBcSlot: %w", err)
	}
	return oldValue.AvailableBcSlot, nil
}

// AddAvailableBcSlot adds i to the "available_bc_slot" field.
func (m *FlightMutation) AddAvailableBcSlot(i int) {
	if m.addavailable_bc_slot != nil {
		*m.addavailable_bc_slot += i
	} else {
		m.addavailable_bc_slot = &i
	}
}

// AddedAvailableBcSlot returns the value that was added to the "available_bc_slot" field in this mutation.
func (m *FlightMutation) AddedAvailableBcSlot() (r int, exists bool) {
	v := m.addavailable_bc_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableBcSlot resets all changes to the "available_bc_slot" field.
func (m *FlightMutation) ResetAvailableBcSlot() {
	m.available_bc_slot = nil
	m.addavailable_bc_slot = nil
}

// SetStatus sets the "status" field.
func (m *FlightMutation) SetStatus(f flight.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FlightMutation) Status() (r flight.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldStatus(ctx context.Context) (v flight.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FlightMutation) ResetStatus() {
	m.status = nil
}

// AddFlightIDIDs adds the "flight_id" edge to the Booking entity by ids.
func (m *FlightMutation) AddFlightIDIDs(ids ...int) {
	if m.flight_id == nil {
		m.flight_id = make(map[int]struct{})
	}
	for i := range ids {
		m.flight_id[ids[i]] = struct{}{}
	}
}

// ClearFlightID clears the "flight_id" edge to the Booking entity.
func (m *FlightMutation) ClearFlightID() {
	m.clearedflight_id = true
}

// FlightIDCleared reports if the "flight_id" edge to the Booking entity was cleared.
func (m *FlightMutation) FlightIDCleared() bool {
	return m.clearedflight_id
}

// RemoveFlightIDIDs removes the "flight_id" edge to the Booking entity by IDs.
func (m *FlightMutation) RemoveFlightIDIDs(ids ...int) {
	if m.removedflight_id == nil {
		m.removedflight_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flight_id, ids[i])
		m.removedflight_id[ids[i]] = struct{}{}
	}
}

// RemovedFlightID returns the removed IDs of the "flight_id" edge to the Booking entity.
func (m *FlightMutation) RemovedFlightIDIDs() (ids []int) {
	for id := range m.removedflight_id {
		ids = append(ids, id)
	}
	return
}

// FlightIDIDs returns the "flight_id" edge IDs in the mutation.
func (m *FlightMutation) FlightIDIDs() (ids []int) {
	for id := range m.flight_id {
		ids = append(ids, id)
	}
	return
}

// ResetFlightID resets all changes to the "flight_id" edge.
func (m *FlightMutation) ResetFlightID() {
	m.flight_id = nil
	m.clearedflight_id = false
	m.removedflight_id = nil
}

// Where appends a list predicates to the FlightMutation builder.
func (m *FlightMutation) Where(ps ...predicate.Flight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FlightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FlightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Flight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FlightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FlightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Flight).
func (m *FlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, flight.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flight.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, flight.FieldName)
	}
	if m.depart_at != nil {
		fields = append(fields, flight.FieldDepartAt)
	}
	if m.land_at != nil {
		fields = append(fields, flight.FieldLandAt)
	}
	if m.available_ec_slot != nil {
		fields = append(fields, flight.FieldAvailableEcSlot)
	}
	if m.available_bc_slot != nil {
		fields = append(fields, flight.FieldAvailableBcSlot)
	}
	if m.status != nil {
		fields = append(fields, flight.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldCreatedAt:
		return m.CreatedAt()
	case flight.FieldUpdatedAt:
		return m.UpdatedAt()
	case flight.FieldName:
		return m.Name()
	case flight.FieldDepartAt:
		return m.DepartAt()
	case flight.FieldLandAt:
		return m.LandAt()
	case flight.FieldAvailableEcSlot:
		return m.AvailableEcSlot()
	case flight.FieldAvailableBcSlot:
		return m.AvailableBcSlot()
	case flight.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flight.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flight.FieldName:
		return m.OldName(ctx)
	case flight.FieldDepartAt:
		return m.OldDepartAt(ctx)
	case flight.FieldLandAt:
		return m.OldLandAt(ctx)
	case flight.FieldAvailableEcSlot:
		return m.OldAvailableEcSlot(ctx)
	case flight.FieldAvailableBcSlot:
		return m.OldAvailableBcSlot(ctx)
	case flight.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Flight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flight.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flight.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flight.FieldDepartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartAt(v)
		return nil
	case flight.FieldLandAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandAt(v)
		return nil
	case flight.FieldAvailableEcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableEcSlot(v)
		return nil
	case flight.FieldAvailableBcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableBcSlot(v)
		return nil
	case flight.FieldStatus:
		v, ok := value.(flight.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightMutation) AddedFields() []string {
	var fields []string
	if m.addavailable_ec_slot != nil {
		fields = append(fields, flight.FieldAvailableEcSlot)
	}
	if m.addavailable_bc_slot != nil {
		fields = append(fields, flight.FieldAvailableBcSlot)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldAvailableEcSlot:
		return m.AddedAvailableEcSlot()
	case flight.FieldAvailableBcSlot:
		return m.AddedAvailableBcSlot()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flight.FieldAvailableEcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableEcSlot(v)
		return nil
	case flight.FieldAvailableBcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableBcSlot(v)
		return nil
	}
	return fmt.Errorf("unknown Flight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Flight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightMutation) ResetField(name string) error {
	switch name {
	case flight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flight.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flight.FieldName:
		m.ResetName()
		return nil
	case flight.FieldDepartAt:
		m.ResetDepartAt()
		return nil
	case flight.FieldLandAt:
		m.ResetLandAt()
		return nil
	case flight.FieldAvailableEcSlot:
		m.ResetAvailableEcSlot()
		return nil
	case flight.FieldAvailableBcSlot:
		m.ResetAvailableBcSlot()
		return nil
	case flight.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.flight_id != nil {
		edges = append(edges, flight.EdgeFlightID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeFlightID:
		ids := make([]ent.Value, 0, len(m.flight_id))
		for id := range m.flight_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedflight_id != nil {
		edges = append(edges, flight.EdgeFlightID)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeFlightID:
		ids := make([]ent.Value, 0, len(m.removedflight_id))
		for id := range m.removedflight_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedflight_id {
		edges = append(edges, flight.EdgeFlightID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightMutation) EdgeCleared(name string) bool {
	switch name {
	case flight.EdgeFlightID:
		return m.clearedflight_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Flight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightMutation) ResetEdge(name string) error {
	switch name {
	case flight.EdgeFlightID:
		m.ResetFlightID()
		return nil
	}
	return fmt.Errorf("unknown Flight edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	updated_at       *time.Time
	email            *string
	password         *string
	phone_number     *string
	full_name        *string
	dob              *time.Time
	cid              *string
	role             *int
	addrole          *int
	clearedFields    map[string]struct{}
	member_id        *int
	clearedmember_id bool
	done             bool
	oldValue         func(context.Context) (*Member, error)
	predicates       []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *MemberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *MemberMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *MemberMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *MemberMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetFullName sets the "full_name" field.
func (m *MemberMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *MemberMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *MemberMutation) ResetFullName() {
	m.full_name = nil
}

// SetDob sets the "dob" field.
func (m *MemberMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *MemberMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ResetDob resets all changes to the "dob" field.
func (m *MemberMutation) ResetDob() {
	m.dob = nil
}

// SetCid sets the "cid" field.
func (m *MemberMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the value of the "cid" field in the mutation.
func (m *MemberMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *MemberMutation) ResetCid() {
	m.cid = nil
}

// SetRole sets the "role" field.
func (m *MemberMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *MemberMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *MemberMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *MemberMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *MemberMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// SetMemberIDID sets the "member_id" edge to the Customer entity by id.
func (m *MemberMutation) SetMemberIDID(id int) {
	m.member_id = &id
}

// ClearMemberID clears the "member_id" edge to the Customer entity.
func (m *MemberMutation) ClearMemberID() {
	m.clearedmember_id = true
}

// MemberIDCleared reports if the "member_id" edge to the Customer entity was cleared.
func (m *MemberMutation) MemberIDCleared() bool {
	return m.clearedmember_id
}

// MemberIDID returns the "member_id" edge ID in the mutation.
func (m *MemberMutation) MemberIDID() (id int, exists bool) {
	if m.member_id != nil {
		return *m.member_id, true
	}
	return
}

// MemberIDIDs returns the "member_id" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MemberIDID instead. It exists only for internal usage by the builders.
func (m *MemberMutation) MemberIDIDs() (ids []int) {
	if id := m.member_id; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMemberID resets all changes to the "member_id" edge.
func (m *MemberMutation) ResetMemberID() {
	m.member_id = nil
	m.clearedmember_id = false
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, member.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.phone_number != nil {
		fields = append(fields, member.FieldPhoneNumber)
	}
	if m.full_name != nil {
		fields = append(fields, member.FieldFullName)
	}
	if m.dob != nil {
		fields = append(fields, member.FieldDob)
	}
	if m.cid != nil {
		fields = append(fields, member.FieldCid)
	}
	if m.role != nil {
		fields = append(fields, member.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldEmail:
		return m.Email()
	case member.FieldPassword:
		return m.Password()
	case member.FieldPhoneNumber:
		return m.PhoneNumber()
	case member.FieldFullName:
		return m.FullName()
	case member.FieldDob:
		return m.Dob()
	case member.FieldCid:
		return m.Cid()
	case member.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldEmail:
		return m.OldEmail(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case member.FieldFullName:
		return m.OldFullName(ctx)
	case member.FieldDob:
		return m.OldDob(ctx)
	case member.FieldCid:
		return m.OldCid(ctx)
	case member.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case member.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case member.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case member.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case member.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, member.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case member.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	case member.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldEmail:
		m.ResetEmail()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case member.FieldFullName:
		m.ResetFullName()
		return nil
	case member.FieldDob:
		m.ResetDob()
		return nil
	case member.FieldCid:
		m.ResetCid()
		return nil
	case member.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.member_id != nil {
		edges = append(edges, member.EdgeMemberID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeMemberID:
		if id := m.member_id; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmember_id {
		edges = append(edges, member.EdgeMemberID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeMemberID:
		return m.clearedmember_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	case member.EdgeMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// PlaneMutation represents an operation that mutates the Plane nodes in the graph.
type PlaneMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	name                    *string
	economy_class_slots     *int64
	addeconomy_class_slots  *int64
	business_class_slots    *int64
	addbusiness_class_slots *int64
	status                  *plane.Status
	clearedFields           map[string]struct{}
	plane_id                map[int]struct{}
	removedplane_id         map[int]struct{}
	clearedplane_id         bool
	done                    bool
	oldValue                func(context.Context) (*Plane, error)
	predicates              []predicate.Plane
}

var _ ent.Mutation = (*PlaneMutation)(nil)

// planeOption allows management of the mutation configuration using functional options.
type planeOption func(*PlaneMutation)

// newPlaneMutation creates new mutation for the Plane entity.
func newPlaneMutation(c config, op Op, opts ...planeOption) *PlaneMutation {
	m := &PlaneMutation{
		config:        c,
		op:            op,
		typ:           TypePlane,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaneID sets the ID field of the mutation.
func withPlaneID(id int) planeOption {
	return func(m *PlaneMutation) {
		var (
			err   error
			once  sync.Once
			value *Plane
		)
		m.oldValue = func(ctx context.Context) (*Plane, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plane.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlane sets the old Plane of the mutation.
func withPlane(node *Plane) planeOption {
	return func(m *PlaneMutation) {
		m.oldValue = func(context.Context) (*Plane, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plane.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PlaneMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaneMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaneMutation) ResetName() {
	m.name = nil
}

// SetEconomyClassSlots sets the "economy_class_slots" field.
func (m *PlaneMutation) SetEconomyClassSlots(i int64) {
	m.economy_class_slots = &i
	m.addeconomy_class_slots = nil
}

// EconomyClassSlots returns the value of the "economy_class_slots" field in the mutation.
func (m *PlaneMutation) EconomyClassSlots() (r int64, exists bool) {
	v := m.economy_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// OldEconomyClassSlots returns the old "economy_class_slots" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldEconomyClassSlots(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEconomyClassSlots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEconomyClassSlots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEconomyClassSlots: %w", err)
	}
	return oldValue.EconomyClassSlots, nil
}

// AddEconomyClassSlots adds i to the "economy_class_slots" field.
func (m *PlaneMutation) AddEconomyClassSlots(i int64) {
	if m.addeconomy_class_slots != nil {
		*m.addeconomy_class_slots += i
	} else {
		m.addeconomy_class_slots = &i
	}
}

// AddedEconomyClassSlots returns the value that was added to the "economy_class_slots" field in this mutation.
func (m *PlaneMutation) AddedEconomyClassSlots() (r int64, exists bool) {
	v := m.addeconomy_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// ResetEconomyClassSlots resets all changes to the "economy_class_slots" field.
func (m *PlaneMutation) ResetEconomyClassSlots() {
	m.economy_class_slots = nil
	m.addeconomy_class_slots = nil
}

// SetBusinessClassSlots sets the "business_class_slots" field.
func (m *PlaneMutation) SetBusinessClassSlots(i int64) {
	m.business_class_slots = &i
	m.addbusiness_class_slots = nil
}

// BusinessClassSlots returns the value of the "business_class_slots" field in the mutation.
func (m *PlaneMutation) BusinessClassSlots() (r int64, exists bool) {
	v := m.business_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessClassSlots returns the old "business_class_slots" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldBusinessClassSlots(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessClassSlots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessClassSlots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessClassSlots: %w", err)
	}
	return oldValue.BusinessClassSlots, nil
}

// AddBusinessClassSlots adds i to the "business_class_slots" field.
func (m *PlaneMutation) AddBusinessClassSlots(i int64) {
	if m.addbusiness_class_slots != nil {
		*m.addbusiness_class_slots += i
	} else {
		m.addbusiness_class_slots = &i
	}
}

// AddedBusinessClassSlots returns the value that was added to the "business_class_slots" field in this mutation.
func (m *PlaneMutation) AddedBusinessClassSlots() (r int64, exists bool) {
	v := m.addbusiness_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusinessClassSlots resets all changes to the "business_class_slots" field.
func (m *PlaneMutation) ResetBusinessClassSlots() {
	m.business_class_slots = nil
	m.addbusiness_class_slots = nil
}

// SetStatus sets the "status" field.
func (m *PlaneMutation) SetStatus(pl plane.Status) {
	m.status = &pl
}

// Status returns the value of the "status" field in the mutation.
func (m *PlaneMutation) Status() (r plane.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldStatus(ctx context.Context) (v plane.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PlaneMutation) ResetStatus() {
	m.status = nil
}

// AddPlaneIDIDs adds the "plane_id" edge to the Flight entity by ids.
func (m *PlaneMutation) AddPlaneIDIDs(ids ...int) {
	if m.plane_id == nil {
		m.plane_id = make(map[int]struct{})
	}
	for i := range ids {
		m.plane_id[ids[i]] = struct{}{}
	}
}

// ClearPlaneID clears the "plane_id" edge to the Flight entity.
func (m *PlaneMutation) ClearPlaneID() {
	m.clearedplane_id = true
}

// PlaneIDCleared reports if the "plane_id" edge to the Flight entity was cleared.
func (m *PlaneMutation) PlaneIDCleared() bool {
	return m.clearedplane_id
}

// RemovePlaneIDIDs removes the "plane_id" edge to the Flight entity by IDs.
func (m *PlaneMutation) RemovePlaneIDIDs(ids ...int) {
	if m.removedplane_id == nil {
		m.removedplane_id = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.plane_id, ids[i])
		m.removedplane_id[ids[i]] = struct{}{}
	}
}

// RemovedPlaneID returns the removed IDs of the "plane_id" edge to the Flight entity.
func (m *PlaneMutation) RemovedPlaneIDIDs() (ids []int) {
	for id := range m.removedplane_id {
		ids = append(ids, id)
	}
	return
}

// PlaneIDIDs returns the "plane_id" edge IDs in the mutation.
func (m *PlaneMutation) PlaneIDIDs() (ids []int) {
	for id := range m.plane_id {
		ids = append(ids, id)
	}
	return
}

// ResetPlaneID resets all changes to the "plane_id" edge.
func (m *PlaneMutation) ResetPlaneID() {
	m.plane_id = nil
	m.clearedplane_id = false
	m.removedplane_id = nil
}

// Where appends a list predicates to the PlaneMutation builder.
func (m *PlaneMutation) Where(ps ...predicate.Plane) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plane, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plane).
func (m *PlaneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaneMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, plane.FieldName)
	}
	if m.economy_class_slots != nil {
		fields = append(fields, plane.FieldEconomyClassSlots)
	}
	if m.business_class_slots != nil {
		fields = append(fields, plane.FieldBusinessClassSlots)
	}
	if m.status != nil {
		fields = append(fields, plane.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plane.FieldName:
		return m.Name()
	case plane.FieldEconomyClassSlots:
		return m.EconomyClassSlots()
	case plane.FieldBusinessClassSlots:
		return m.BusinessClassSlots()
	case plane.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plane.FieldName:
		return m.OldName(ctx)
	case plane.FieldEconomyClassSlots:
		return m.OldEconomyClassSlots(ctx)
	case plane.FieldBusinessClassSlots:
		return m.OldBusinessClassSlots(ctx)
	case plane.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Plane field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plane.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plane.FieldEconomyClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEconomyClassSlots(v)
		return nil
	case plane.FieldBusinessClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessClassSlots(v)
		return nil
	case plane.FieldStatus:
		v, ok := value.(plane.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Plane field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaneMutation) AddedFields() []string {
	var fields []string
	if m.addeconomy_class_slots != nil {
		fields = append(fields, plane.FieldEconomyClassSlots)
	}
	if m.addbusiness_class_slots != nil {
		fields = append(fields, plane.FieldBusinessClassSlots)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plane.FieldEconomyClassSlots:
		return m.AddedEconomyClassSlots()
	case plane.FieldBusinessClassSlots:
		return m.AddedBusinessClassSlots()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plane.FieldEconomyClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEconomyClassSlots(v)
		return nil
	case plane.FieldBusinessClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusinessClassSlots(v)
		return nil
	}
	return fmt.Errorf("unknown Plane numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Plane nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaneMutation) ResetField(name string) error {
	switch name {
	case plane.FieldName:
		m.ResetName()
		return nil
	case plane.FieldEconomyClassSlots:
		m.ResetEconomyClassSlots()
		return nil
	case plane.FieldBusinessClassSlots:
		m.ResetBusinessClassSlots()
		return nil
	case plane.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Plane field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.plane_id != nil {
		edges = append(edges, plane.EdgePlaneID)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plane.EdgePlaneID:
		ids := make([]ent.Value, 0, len(m.plane_id))
		for id := range m.plane_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedplane_id != nil {
		edges = append(edges, plane.EdgePlaneID)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plane.EdgePlaneID:
		ids := make([]ent.Value, 0, len(m.removedplane_id))
		for id := range m.removedplane_id {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedplane_id {
		edges = append(edges, plane.EdgePlaneID)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaneMutation) EdgeCleared(name string) bool {
	switch name {
	case plane.EdgePlaneID:
		return m.clearedplane_id
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaneMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plane unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaneMutation) ResetEdge(name string) error {
	switch name {
	case plane.EdgePlaneID:
		m.ResetPlaneID()
		return nil
	}
	return fmt.Errorf("unknown Plane edge %s", name)
}
