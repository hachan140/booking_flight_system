// Code generated by ent, DO NOT EDIT.

package ent

import (
	"booking-flight-system/ent/airport"
	"booking-flight-system/ent/booking"
	"booking-flight-system/ent/customer"
	"booking-flight-system/ent/flight"
	"booking-flight-system/ent/member"
	"booking-flight-system/ent/plane"
	"booking-flight-system/ent/predicate"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAirport  = "Airport"
	TypeBooking  = "Booking"
	TypeCustomer = "Customer"
	TypeFlight   = "Flight"
	TypeMember   = "Member"
	TypePlane    = "Plane"
)

// AirportMutation represents an operation that mutates the Airport nodes in the graph.
type AirportMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	name               *string
	lat                *float64
	addlat             *float64
	long               *float64
	addlong            *float64
	clearedFields      map[string]struct{}
	from_flight        map[int]struct{}
	removedfrom_flight map[int]struct{}
	clearedfrom_flight bool
	to_flight          map[int]struct{}
	removedto_flight   map[int]struct{}
	clearedto_flight   bool
	done               bool
	oldValue           func(context.Context) (*Airport, error)
	predicates         []predicate.Airport
}

var _ ent.Mutation = (*AirportMutation)(nil)

// airportOption allows management of the mutation configuration using functional options.
type airportOption func(*AirportMutation)

// newAirportMutation creates new mutation for the Airport entity.
func newAirportMutation(c config, op Op, opts ...airportOption) *AirportMutation {
	m := &AirportMutation{
		config:        c,
		op:            op,
		typ:           TypeAirport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAirportID sets the ID field of the mutation.
func withAirportID(id int) airportOption {
	return func(m *AirportMutation) {
		var (
			err   error
			once  sync.Once
			value *Airport
		)
		m.oldValue = func(ctx context.Context) (*Airport, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Airport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAirport sets the old Airport of the mutation.
func withAirport(node *Airport) airportOption {
	return func(m *AirportMutation) {
		m.oldValue = func(context.Context) (*Airport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AirportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AirportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AirportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AirportMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Airport.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AirportMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AirportMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AirportMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AirportMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AirportMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AirportMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *AirportMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AirportMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AirportMutation) ResetName() {
	m.name = nil
}

// SetLat sets the "lat" field.
func (m *AirportMutation) SetLat(f float64) {
	m.lat = &f
	m.addlat = nil
}

// Lat returns the value of the "lat" field in the mutation.
func (m *AirportMutation) Lat() (r float64, exists bool) {
	v := m.lat
	if v == nil {
		return
	}
	return *v, true
}

// OldLat returns the old "lat" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLat: %w", err)
	}
	return oldValue.Lat, nil
}

// AddLat adds f to the "lat" field.
func (m *AirportMutation) AddLat(f float64) {
	if m.addlat != nil {
		*m.addlat += f
	} else {
		m.addlat = &f
	}
}

// AddedLat returns the value that was added to the "lat" field in this mutation.
func (m *AirportMutation) AddedLat() (r float64, exists bool) {
	v := m.addlat
	if v == nil {
		return
	}
	return *v, true
}

// ResetLat resets all changes to the "lat" field.
func (m *AirportMutation) ResetLat() {
	m.lat = nil
	m.addlat = nil
}

// SetLong sets the "long" field.
func (m *AirportMutation) SetLong(f float64) {
	m.long = &f
	m.addlong = nil
}

// Long returns the value of the "long" field in the mutation.
func (m *AirportMutation) Long() (r float64, exists bool) {
	v := m.long
	if v == nil {
		return
	}
	return *v, true
}

// OldLong returns the old "long" field's value of the Airport entity.
// If the Airport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AirportMutation) OldLong(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLong is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLong requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLong: %w", err)
	}
	return oldValue.Long, nil
}

// AddLong adds f to the "long" field.
func (m *AirportMutation) AddLong(f float64) {
	if m.addlong != nil {
		*m.addlong += f
	} else {
		m.addlong = &f
	}
}

// AddedLong returns the value that was added to the "long" field in this mutation.
func (m *AirportMutation) AddedLong() (r float64, exists bool) {
	v := m.addlong
	if v == nil {
		return
	}
	return *v, true
}

// ResetLong resets all changes to the "long" field.
func (m *AirportMutation) ResetLong() {
	m.long = nil
	m.addlong = nil
}

// AddFromFlightIDs adds the "from_flight" edge to the Flight entity by ids.
func (m *AirportMutation) AddFromFlightIDs(ids ...int) {
	if m.from_flight == nil {
		m.from_flight = make(map[int]struct{})
	}
	for i := range ids {
		m.from_flight[ids[i]] = struct{}{}
	}
}

// ClearFromFlight clears the "from_flight" edge to the Flight entity.
func (m *AirportMutation) ClearFromFlight() {
	m.clearedfrom_flight = true
}

// FromFlightCleared reports if the "from_flight" edge to the Flight entity was cleared.
func (m *AirportMutation) FromFlightCleared() bool {
	return m.clearedfrom_flight
}

// RemoveFromFlightIDs removes the "from_flight" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveFromFlightIDs(ids ...int) {
	if m.removedfrom_flight == nil {
		m.removedfrom_flight = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.from_flight, ids[i])
		m.removedfrom_flight[ids[i]] = struct{}{}
	}
}

// RemovedFromFlight returns the removed IDs of the "from_flight" edge to the Flight entity.
func (m *AirportMutation) RemovedFromFlightIDs() (ids []int) {
	for id := range m.removedfrom_flight {
		ids = append(ids, id)
	}
	return
}

// FromFlightIDs returns the "from_flight" edge IDs in the mutation.
func (m *AirportMutation) FromFlightIDs() (ids []int) {
	for id := range m.from_flight {
		ids = append(ids, id)
	}
	return
}

// ResetFromFlight resets all changes to the "from_flight" edge.
func (m *AirportMutation) ResetFromFlight() {
	m.from_flight = nil
	m.clearedfrom_flight = false
	m.removedfrom_flight = nil
}

// AddToFlightIDs adds the "to_flight" edge to the Flight entity by ids.
func (m *AirportMutation) AddToFlightIDs(ids ...int) {
	if m.to_flight == nil {
		m.to_flight = make(map[int]struct{})
	}
	for i := range ids {
		m.to_flight[ids[i]] = struct{}{}
	}
}

// ClearToFlight clears the "to_flight" edge to the Flight entity.
func (m *AirportMutation) ClearToFlight() {
	m.clearedto_flight = true
}

// ToFlightCleared reports if the "to_flight" edge to the Flight entity was cleared.
func (m *AirportMutation) ToFlightCleared() bool {
	return m.clearedto_flight
}

// RemoveToFlightIDs removes the "to_flight" edge to the Flight entity by IDs.
func (m *AirportMutation) RemoveToFlightIDs(ids ...int) {
	if m.removedto_flight == nil {
		m.removedto_flight = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.to_flight, ids[i])
		m.removedto_flight[ids[i]] = struct{}{}
	}
}

// RemovedToFlight returns the removed IDs of the "to_flight" edge to the Flight entity.
func (m *AirportMutation) RemovedToFlightIDs() (ids []int) {
	for id := range m.removedto_flight {
		ids = append(ids, id)
	}
	return
}

// ToFlightIDs returns the "to_flight" edge IDs in the mutation.
func (m *AirportMutation) ToFlightIDs() (ids []int) {
	for id := range m.to_flight {
		ids = append(ids, id)
	}
	return
}

// ResetToFlight resets all changes to the "to_flight" edge.
func (m *AirportMutation) ResetToFlight() {
	m.to_flight = nil
	m.clearedto_flight = false
	m.removedto_flight = nil
}

// Where appends a list predicates to the AirportMutation builder.
func (m *AirportMutation) Where(ps ...predicate.Airport) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AirportMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AirportMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Airport, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AirportMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AirportMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Airport).
func (m *AirportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AirportMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, airport.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, airport.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, airport.FieldName)
	}
	if m.lat != nil {
		fields = append(fields, airport.FieldLat)
	}
	if m.long != nil {
		fields = append(fields, airport.FieldLong)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AirportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldCreatedAt:
		return m.CreatedAt()
	case airport.FieldUpdatedAt:
		return m.UpdatedAt()
	case airport.FieldName:
		return m.Name()
	case airport.FieldLat:
		return m.Lat()
	case airport.FieldLong:
		return m.Long()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AirportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case airport.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case airport.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case airport.FieldName:
		return m.OldName(ctx)
	case airport.FieldLat:
		return m.OldLat(ctx)
	case airport.FieldLong:
		return m.OldLong(ctx)
	}
	return nil, fmt.Errorf("unknown Airport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case airport.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case airport.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case airport.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case airport.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLat(v)
		return nil
	case airport.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLong(v)
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AirportMutation) AddedFields() []string {
	var fields []string
	if m.addlat != nil {
		fields = append(fields, airport.FieldLat)
	}
	if m.addlong != nil {
		fields = append(fields, airport.FieldLong)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AirportMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case airport.FieldLat:
		return m.AddedLat()
	case airport.FieldLong:
		return m.AddedLong()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AirportMutation) AddField(name string, value ent.Value) error {
	switch name {
	case airport.FieldLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLat(v)
		return nil
	case airport.FieldLong:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLong(v)
		return nil
	}
	return fmt.Errorf("unknown Airport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AirportMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AirportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AirportMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Airport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AirportMutation) ResetField(name string) error {
	switch name {
	case airport.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case airport.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case airport.FieldName:
		m.ResetName()
		return nil
	case airport.FieldLat:
		m.ResetLat()
		return nil
	case airport.FieldLong:
		m.ResetLong()
		return nil
	}
	return fmt.Errorf("unknown Airport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AirportMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.from_flight != nil {
		edges = append(edges, airport.EdgeFromFlight)
	}
	if m.to_flight != nil {
		edges = append(edges, airport.EdgeToFlight)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AirportMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeFromFlight:
		ids := make([]ent.Value, 0, len(m.from_flight))
		for id := range m.from_flight {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeToFlight:
		ids := make([]ent.Value, 0, len(m.to_flight))
		for id := range m.to_flight {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AirportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedfrom_flight != nil {
		edges = append(edges, airport.EdgeFromFlight)
	}
	if m.removedto_flight != nil {
		edges = append(edges, airport.EdgeToFlight)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AirportMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case airport.EdgeFromFlight:
		ids := make([]ent.Value, 0, len(m.removedfrom_flight))
		for id := range m.removedfrom_flight {
			ids = append(ids, id)
		}
		return ids
	case airport.EdgeToFlight:
		ids := make([]ent.Value, 0, len(m.removedto_flight))
		for id := range m.removedto_flight {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AirportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedfrom_flight {
		edges = append(edges, airport.EdgeFromFlight)
	}
	if m.clearedto_flight {
		edges = append(edges, airport.EdgeToFlight)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AirportMutation) EdgeCleared(name string) bool {
	switch name {
	case airport.EdgeFromFlight:
		return m.clearedfrom_flight
	case airport.EdgeToFlight:
		return m.clearedto_flight
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AirportMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Airport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AirportMutation) ResetEdge(name string) error {
	switch name {
	case airport.EdgeFromFlight:
		m.ResetFromFlight()
		return nil
	case airport.EdgeToFlight:
		m.ResetToFlight()
		return nil
	}
	return fmt.Errorf("unknown Airport edge %s", name)
}

// BookingMutation represents an operation that mutates the Booking nodes in the graph.
type BookingMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	code                *string
	status              *booking.Status
	seat_type           *booking.SeatType
	clearedFields       map[string]struct{}
	has_flight          *int
	clearedhas_flight   bool
	has_customer        *int
	clearedhas_customer bool
	done                bool
	oldValue            func(context.Context) (*Booking, error)
	predicates          []predicate.Booking
}

var _ ent.Mutation = (*BookingMutation)(nil)

// bookingOption allows management of the mutation configuration using functional options.
type bookingOption func(*BookingMutation)

// newBookingMutation creates new mutation for the Booking entity.
func newBookingMutation(c config, op Op, opts ...bookingOption) *BookingMutation {
	m := &BookingMutation{
		config:        c,
		op:            op,
		typ:           TypeBooking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBookingID sets the ID field of the mutation.
func withBookingID(id int) bookingOption {
	return func(m *BookingMutation) {
		var (
			err   error
			once  sync.Once
			value *Booking
		)
		m.oldValue = func(ctx context.Context) (*Booking, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Booking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBooking sets the old Booking of the mutation.
func withBooking(node *Booking) bookingOption {
	return func(m *BookingMutation) {
		m.oldValue = func(context.Context) (*Booking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BookingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BookingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BookingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BookingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Booking.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *BookingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *BookingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *BookingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *BookingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *BookingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *BookingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCode sets the "code" field.
func (m *BookingMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *BookingMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *BookingMutation) ResetCode() {
	m.code = nil
}

// SetStatus sets the "status" field.
func (m *BookingMutation) SetStatus(b booking.Status) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *BookingMutation) Status() (r booking.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldStatus(ctx context.Context) (v booking.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *BookingMutation) ResetStatus() {
	m.status = nil
}

// SetSeatType sets the "seat_type" field.
func (m *BookingMutation) SetSeatType(bt booking.SeatType) {
	m.seat_type = &bt
}

// SeatType returns the value of the "seat_type" field in the mutation.
func (m *BookingMutation) SeatType() (r booking.SeatType, exists bool) {
	v := m.seat_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatType returns the old "seat_type" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldSeatType(ctx context.Context) (v booking.SeatType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatType: %w", err)
	}
	return oldValue.SeatType, nil
}

// ResetSeatType resets all changes to the "seat_type" field.
func (m *BookingMutation) ResetSeatType() {
	m.seat_type = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *BookingMutation) SetCustomerID(i int) {
	m.has_customer = &i
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *BookingMutation) CustomerID() (r int, exists bool) {
	v := m.has_customer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldCustomerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *BookingMutation) ClearCustomerID() {
	m.has_customer = nil
	m.clearedFields[booking.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *BookingMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[booking.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *BookingMutation) ResetCustomerID() {
	m.has_customer = nil
	delete(m.clearedFields, booking.FieldCustomerID)
}

// SetFlightID sets the "flight_id" field.
func (m *BookingMutation) SetFlightID(i int) {
	m.has_flight = &i
}

// FlightID returns the value of the "flight_id" field in the mutation.
func (m *BookingMutation) FlightID() (r int, exists bool) {
	v := m.has_flight
	if v == nil {
		return
	}
	return *v, true
}

// OldFlightID returns the old "flight_id" field's value of the Booking entity.
// If the Booking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BookingMutation) OldFlightID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlightID: %w", err)
	}
	return oldValue.FlightID, nil
}

// ClearFlightID clears the value of the "flight_id" field.
func (m *BookingMutation) ClearFlightID() {
	m.has_flight = nil
	m.clearedFields[booking.FieldFlightID] = struct{}{}
}

// FlightIDCleared returns if the "flight_id" field was cleared in this mutation.
func (m *BookingMutation) FlightIDCleared() bool {
	_, ok := m.clearedFields[booking.FieldFlightID]
	return ok
}

// ResetFlightID resets all changes to the "flight_id" field.
func (m *BookingMutation) ResetFlightID() {
	m.has_flight = nil
	delete(m.clearedFields, booking.FieldFlightID)
}

// SetHasFlightID sets the "has_flight" edge to the Flight entity by id.
func (m *BookingMutation) SetHasFlightID(id int) {
	m.has_flight = &id
}

// ClearHasFlight clears the "has_flight" edge to the Flight entity.
func (m *BookingMutation) ClearHasFlight() {
	m.clearedhas_flight = true
}

// HasFlightCleared reports if the "has_flight" edge to the Flight entity was cleared.
func (m *BookingMutation) HasFlightCleared() bool {
	return m.FlightIDCleared() || m.clearedhas_flight
}

// HasFlightID returns the "has_flight" edge ID in the mutation.
func (m *BookingMutation) HasFlightID() (id int, exists bool) {
	if m.has_flight != nil {
		return *m.has_flight, true
	}
	return
}

// HasFlightIDs returns the "has_flight" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HasFlightID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) HasFlightIDs() (ids []int) {
	if id := m.has_flight; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasFlight resets all changes to the "has_flight" edge.
func (m *BookingMutation) ResetHasFlight() {
	m.has_flight = nil
	m.clearedhas_flight = false
}

// SetHasCustomerID sets the "has_customer" edge to the Customer entity by id.
func (m *BookingMutation) SetHasCustomerID(id int) {
	m.has_customer = &id
}

// ClearHasCustomer clears the "has_customer" edge to the Customer entity.
func (m *BookingMutation) ClearHasCustomer() {
	m.clearedhas_customer = true
}

// HasCustomerCleared reports if the "has_customer" edge to the Customer entity was cleared.
func (m *BookingMutation) HasCustomerCleared() bool {
	return m.CustomerIDCleared() || m.clearedhas_customer
}

// HasCustomerID returns the "has_customer" edge ID in the mutation.
func (m *BookingMutation) HasCustomerID() (id int, exists bool) {
	if m.has_customer != nil {
		return *m.has_customer, true
	}
	return
}

// HasCustomerIDs returns the "has_customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HasCustomerID instead. It exists only for internal usage by the builders.
func (m *BookingMutation) HasCustomerIDs() (ids []int) {
	if id := m.has_customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasCustomer resets all changes to the "has_customer" edge.
func (m *BookingMutation) ResetHasCustomer() {
	m.has_customer = nil
	m.clearedhas_customer = false
}

// Where appends a list predicates to the BookingMutation builder.
func (m *BookingMutation) Where(ps ...predicate.Booking) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BookingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BookingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Booking, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BookingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BookingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Booking).
func (m *BookingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BookingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, booking.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, booking.FieldUpdatedAt)
	}
	if m.code != nil {
		fields = append(fields, booking.FieldCode)
	}
	if m.status != nil {
		fields = append(fields, booking.FieldStatus)
	}
	if m.seat_type != nil {
		fields = append(fields, booking.FieldSeatType)
	}
	if m.has_customer != nil {
		fields = append(fields, booking.FieldCustomerID)
	}
	if m.has_flight != nil {
		fields = append(fields, booking.FieldFlightID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BookingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case booking.FieldCreatedAt:
		return m.CreatedAt()
	case booking.FieldUpdatedAt:
		return m.UpdatedAt()
	case booking.FieldCode:
		return m.Code()
	case booking.FieldStatus:
		return m.Status()
	case booking.FieldSeatType:
		return m.SeatType()
	case booking.FieldCustomerID:
		return m.CustomerID()
	case booking.FieldFlightID:
		return m.FlightID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BookingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case booking.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case booking.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case booking.FieldCode:
		return m.OldCode(ctx)
	case booking.FieldStatus:
		return m.OldStatus(ctx)
	case booking.FieldSeatType:
		return m.OldSeatType(ctx)
	case booking.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case booking.FieldFlightID:
		return m.OldFlightID(ctx)
	}
	return nil, fmt.Errorf("unknown Booking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case booking.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case booking.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case booking.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case booking.FieldStatus:
		v, ok := value.(booking.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case booking.FieldSeatType:
		v, ok := value.(booking.SeatType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatType(v)
		return nil
	case booking.FieldCustomerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case booking.FieldFlightID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlightID(v)
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BookingMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BookingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BookingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Booking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BookingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(booking.FieldCustomerID) {
		fields = append(fields, booking.FieldCustomerID)
	}
	if m.FieldCleared(booking.FieldFlightID) {
		fields = append(fields, booking.FieldFlightID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BookingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BookingMutation) ClearField(name string) error {
	switch name {
	case booking.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case booking.FieldFlightID:
		m.ClearFlightID()
		return nil
	}
	return fmt.Errorf("unknown Booking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BookingMutation) ResetField(name string) error {
	switch name {
	case booking.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case booking.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case booking.FieldCode:
		m.ResetCode()
		return nil
	case booking.FieldStatus:
		m.ResetStatus()
		return nil
	case booking.FieldSeatType:
		m.ResetSeatType()
		return nil
	case booking.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case booking.FieldFlightID:
		m.ResetFlightID()
		return nil
	}
	return fmt.Errorf("unknown Booking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BookingMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.has_flight != nil {
		edges = append(edges, booking.EdgeHasFlight)
	}
	if m.has_customer != nil {
		edges = append(edges, booking.EdgeHasCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BookingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case booking.EdgeHasFlight:
		if id := m.has_flight; id != nil {
			return []ent.Value{*id}
		}
	case booking.EdgeHasCustomer:
		if id := m.has_customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BookingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BookingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BookingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhas_flight {
		edges = append(edges, booking.EdgeHasFlight)
	}
	if m.clearedhas_customer {
		edges = append(edges, booking.EdgeHasCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BookingMutation) EdgeCleared(name string) bool {
	switch name {
	case booking.EdgeHasFlight:
		return m.clearedhas_flight
	case booking.EdgeHasCustomer:
		return m.clearedhas_customer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BookingMutation) ClearEdge(name string) error {
	switch name {
	case booking.EdgeHasFlight:
		m.ClearHasFlight()
		return nil
	case booking.EdgeHasCustomer:
		m.ClearHasCustomer()
		return nil
	}
	return fmt.Errorf("unknown Booking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BookingMutation) ResetEdge(name string) error {
	switch name {
	case booking.EdgeHasFlight:
		m.ResetHasFlight()
		return nil
	case booking.EdgeHasCustomer:
		m.ResetHasCustomer()
		return nil
	}
	return fmt.Errorf("unknown Booking edge %s", name)
}

// CustomerMutation represents an operation that mutates the Customer nodes in the graph.
type CustomerMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	email              *string
	phone_number       *string
	full_name          *string
	dob                *time.Time
	cid                *string
	clearedFields      map[string]struct{}
	has_member         *int
	clearedhas_member  bool
	has_booking        map[int]struct{}
	removedhas_booking map[int]struct{}
	clearedhas_booking bool
	done               bool
	oldValue           func(context.Context) (*Customer, error)
	predicates         []predicate.Customer
}

var _ ent.Mutation = (*CustomerMutation)(nil)

// customerOption allows management of the mutation configuration using functional options.
type customerOption func(*CustomerMutation)

// newCustomerMutation creates new mutation for the Customer entity.
func newCustomerMutation(c config, op Op, opts ...customerOption) *CustomerMutation {
	m := &CustomerMutation{
		config:        c,
		op:            op,
		typ:           TypeCustomer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCustomerID sets the ID field of the mutation.
func withCustomerID(id int) customerOption {
	return func(m *CustomerMutation) {
		var (
			err   error
			once  sync.Once
			value *Customer
		)
		m.oldValue = func(ctx context.Context) (*Customer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Customer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCustomer sets the old Customer of the mutation.
func withCustomer(node *Customer) customerOption {
	return func(m *CustomerMutation) {
		m.oldValue = func(context.Context) (*Customer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CustomerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CustomerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CustomerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CustomerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Customer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CustomerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CustomerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CustomerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CustomerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CustomerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CustomerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *CustomerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *CustomerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *CustomerMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *CustomerMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *CustomerMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *CustomerMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetFullName sets the "full_name" field.
func (m *CustomerMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *CustomerMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *CustomerMutation) ResetFullName() {
	m.full_name = nil
}

// SetDob sets the "dob" field.
func (m *CustomerMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *CustomerMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ClearDob clears the value of the "dob" field.
func (m *CustomerMutation) ClearDob() {
	m.dob = nil
	m.clearedFields[customer.FieldDob] = struct{}{}
}

// DobCleared returns if the "dob" field was cleared in this mutation.
func (m *CustomerMutation) DobCleared() bool {
	_, ok := m.clearedFields[customer.FieldDob]
	return ok
}

// ResetDob resets all changes to the "dob" field.
func (m *CustomerMutation) ResetDob() {
	m.dob = nil
	delete(m.clearedFields, customer.FieldDob)
}

// SetCid sets the "cid" field.
func (m *CustomerMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the value of the "cid" field in the mutation.
func (m *CustomerMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldCid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *CustomerMutation) ResetCid() {
	m.cid = nil
}

// SetMemberID sets the "member_id" field.
func (m *CustomerMutation) SetMemberID(i int) {
	m.has_member = &i
}

// MemberID returns the value of the "member_id" field in the mutation.
func (m *CustomerMutation) MemberID() (r int, exists bool) {
	v := m.has_member
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberID returns the old "member_id" field's value of the Customer entity.
// If the Customer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CustomerMutation) OldMemberID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberID: %w", err)
	}
	return oldValue.MemberID, nil
}

// ClearMemberID clears the value of the "member_id" field.
func (m *CustomerMutation) ClearMemberID() {
	m.has_member = nil
	m.clearedFields[customer.FieldMemberID] = struct{}{}
}

// MemberIDCleared returns if the "member_id" field was cleared in this mutation.
func (m *CustomerMutation) MemberIDCleared() bool {
	_, ok := m.clearedFields[customer.FieldMemberID]
	return ok
}

// ResetMemberID resets all changes to the "member_id" field.
func (m *CustomerMutation) ResetMemberID() {
	m.has_member = nil
	delete(m.clearedFields, customer.FieldMemberID)
}

// SetHasMemberID sets the "has_member" edge to the Member entity by id.
func (m *CustomerMutation) SetHasMemberID(id int) {
	m.has_member = &id
}

// ClearHasMember clears the "has_member" edge to the Member entity.
func (m *CustomerMutation) ClearHasMember() {
	m.clearedhas_member = true
}

// HasMemberCleared reports if the "has_member" edge to the Member entity was cleared.
func (m *CustomerMutation) HasMemberCleared() bool {
	return m.MemberIDCleared() || m.clearedhas_member
}

// HasMemberID returns the "has_member" edge ID in the mutation.
func (m *CustomerMutation) HasMemberID() (id int, exists bool) {
	if m.has_member != nil {
		return *m.has_member, true
	}
	return
}

// HasMemberIDs returns the "has_member" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HasMemberID instead. It exists only for internal usage by the builders.
func (m *CustomerMutation) HasMemberIDs() (ids []int) {
	if id := m.has_member; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasMember resets all changes to the "has_member" edge.
func (m *CustomerMutation) ResetHasMember() {
	m.has_member = nil
	m.clearedhas_member = false
}

// AddHasBookingIDs adds the "has_booking" edge to the Booking entity by ids.
func (m *CustomerMutation) AddHasBookingIDs(ids ...int) {
	if m.has_booking == nil {
		m.has_booking = make(map[int]struct{})
	}
	for i := range ids {
		m.has_booking[ids[i]] = struct{}{}
	}
}

// ClearHasBooking clears the "has_booking" edge to the Booking entity.
func (m *CustomerMutation) ClearHasBooking() {
	m.clearedhas_booking = true
}

// HasBookingCleared reports if the "has_booking" edge to the Booking entity was cleared.
func (m *CustomerMutation) HasBookingCleared() bool {
	return m.clearedhas_booking
}

// RemoveHasBookingIDs removes the "has_booking" edge to the Booking entity by IDs.
func (m *CustomerMutation) RemoveHasBookingIDs(ids ...int) {
	if m.removedhas_booking == nil {
		m.removedhas_booking = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_booking, ids[i])
		m.removedhas_booking[ids[i]] = struct{}{}
	}
}

// RemovedHasBooking returns the removed IDs of the "has_booking" edge to the Booking entity.
func (m *CustomerMutation) RemovedHasBookingIDs() (ids []int) {
	for id := range m.removedhas_booking {
		ids = append(ids, id)
	}
	return
}

// HasBookingIDs returns the "has_booking" edge IDs in the mutation.
func (m *CustomerMutation) HasBookingIDs() (ids []int) {
	for id := range m.has_booking {
		ids = append(ids, id)
	}
	return
}

// ResetHasBooking resets all changes to the "has_booking" edge.
func (m *CustomerMutation) ResetHasBooking() {
	m.has_booking = nil
	m.clearedhas_booking = false
	m.removedhas_booking = nil
}

// Where appends a list predicates to the CustomerMutation builder.
func (m *CustomerMutation) Where(ps ...predicate.Customer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CustomerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CustomerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Customer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CustomerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CustomerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Customer).
func (m *CustomerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CustomerMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, customer.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, customer.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, customer.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, customer.FieldPhoneNumber)
	}
	if m.full_name != nil {
		fields = append(fields, customer.FieldFullName)
	}
	if m.dob != nil {
		fields = append(fields, customer.FieldDob)
	}
	if m.cid != nil {
		fields = append(fields, customer.FieldCid)
	}
	if m.has_member != nil {
		fields = append(fields, customer.FieldMemberID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CustomerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case customer.FieldCreatedAt:
		return m.CreatedAt()
	case customer.FieldUpdatedAt:
		return m.UpdatedAt()
	case customer.FieldEmail:
		return m.Email()
	case customer.FieldPhoneNumber:
		return m.PhoneNumber()
	case customer.FieldFullName:
		return m.FullName()
	case customer.FieldDob:
		return m.Dob()
	case customer.FieldCid:
		return m.Cid()
	case customer.FieldMemberID:
		return m.MemberID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CustomerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case customer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case customer.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case customer.FieldEmail:
		return m.OldEmail(ctx)
	case customer.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case customer.FieldFullName:
		return m.OldFullName(ctx)
	case customer.FieldDob:
		return m.OldDob(ctx)
	case customer.FieldCid:
		return m.OldCid(ctx)
	case customer.FieldMemberID:
		return m.OldMemberID(ctx)
	}
	return nil, fmt.Errorf("unknown Customer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case customer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case customer.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case customer.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case customer.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case customer.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case customer.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case customer.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case customer.FieldMemberID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberID(v)
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CustomerMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CustomerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CustomerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Customer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CustomerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(customer.FieldDob) {
		fields = append(fields, customer.FieldDob)
	}
	if m.FieldCleared(customer.FieldMemberID) {
		fields = append(fields, customer.FieldMemberID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CustomerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CustomerMutation) ClearField(name string) error {
	switch name {
	case customer.FieldDob:
		m.ClearDob()
		return nil
	case customer.FieldMemberID:
		m.ClearMemberID()
		return nil
	}
	return fmt.Errorf("unknown Customer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CustomerMutation) ResetField(name string) error {
	switch name {
	case customer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case customer.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case customer.FieldEmail:
		m.ResetEmail()
		return nil
	case customer.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case customer.FieldFullName:
		m.ResetFullName()
		return nil
	case customer.FieldDob:
		m.ResetDob()
		return nil
	case customer.FieldCid:
		m.ResetCid()
		return nil
	case customer.FieldMemberID:
		m.ResetMemberID()
		return nil
	}
	return fmt.Errorf("unknown Customer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CustomerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.has_member != nil {
		edges = append(edges, customer.EdgeHasMember)
	}
	if m.has_booking != nil {
		edges = append(edges, customer.EdgeHasBooking)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CustomerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeHasMember:
		if id := m.has_member; id != nil {
			return []ent.Value{*id}
		}
	case customer.EdgeHasBooking:
		ids := make([]ent.Value, 0, len(m.has_booking))
		for id := range m.has_booking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CustomerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhas_booking != nil {
		edges = append(edges, customer.EdgeHasBooking)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CustomerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case customer.EdgeHasBooking:
		ids := make([]ent.Value, 0, len(m.removedhas_booking))
		for id := range m.removedhas_booking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CustomerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedhas_member {
		edges = append(edges, customer.EdgeHasMember)
	}
	if m.clearedhas_booking {
		edges = append(edges, customer.EdgeHasBooking)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CustomerMutation) EdgeCleared(name string) bool {
	switch name {
	case customer.EdgeHasMember:
		return m.clearedhas_member
	case customer.EdgeHasBooking:
		return m.clearedhas_booking
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CustomerMutation) ClearEdge(name string) error {
	switch name {
	case customer.EdgeHasMember:
		m.ClearHasMember()
		return nil
	}
	return fmt.Errorf("unknown Customer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CustomerMutation) ResetEdge(name string) error {
	switch name {
	case customer.EdgeHasMember:
		m.ResetHasMember()
		return nil
	case customer.EdgeHasBooking:
		m.ResetHasBooking()
		return nil
	}
	return fmt.Errorf("unknown Customer edge %s", name)
}

// FlightMutation represents an operation that mutates the Flight nodes in the graph.
type FlightMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	created_at           *time.Time
	updated_at           *time.Time
	name                 *string
	depart_at            *time.Time
	land_at              *time.Time
	available_ec_slot    *int
	addavailable_ec_slot *int
	available_bc_slot    *int
	addavailable_bc_slot *int
	status               *flight.Status
	clearedFields        map[string]struct{}
	has_plane            *int
	clearedhas_plane     bool
	has_booking          map[int]struct{}
	removedhas_booking   map[int]struct{}
	clearedhas_booking   bool
	from_airport         *int
	clearedfrom_airport  bool
	to_airport           *int
	clearedto_airport    bool
	done                 bool
	oldValue             func(context.Context) (*Flight, error)
	predicates           []predicate.Flight
}

var _ ent.Mutation = (*FlightMutation)(nil)

// flightOption allows management of the mutation configuration using functional options.
type flightOption func(*FlightMutation)

// newFlightMutation creates new mutation for the Flight entity.
func newFlightMutation(c config, op Op, opts ...flightOption) *FlightMutation {
	m := &FlightMutation{
		config:        c,
		op:            op,
		typ:           TypeFlight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlightID sets the ID field of the mutation.
func withFlightID(id int) flightOption {
	return func(m *FlightMutation) {
		var (
			err   error
			once  sync.Once
			value *Flight
		)
		m.oldValue = func(ctx context.Context) (*Flight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Flight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlight sets the old Flight of the mutation.
func withFlight(node *Flight) flightOption {
	return func(m *FlightMutation) {
		m.oldValue = func(context.Context) (*Flight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlightMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlightMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Flight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *FlightMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FlightMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FlightMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FlightMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FlightMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FlightMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *FlightMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FlightMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FlightMutation) ResetName() {
	m.name = nil
}

// SetDepartAt sets the "depart_at" field.
func (m *FlightMutation) SetDepartAt(t time.Time) {
	m.depart_at = &t
}

// DepartAt returns the value of the "depart_at" field in the mutation.
func (m *FlightMutation) DepartAt() (r time.Time, exists bool) {
	v := m.depart_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartAt returns the old "depart_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldDepartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartAt: %w", err)
	}
	return oldValue.DepartAt, nil
}

// ResetDepartAt resets all changes to the "depart_at" field.
func (m *FlightMutation) ResetDepartAt() {
	m.depart_at = nil
}

// SetLandAt sets the "land_at" field.
func (m *FlightMutation) SetLandAt(t time.Time) {
	m.land_at = &t
}

// LandAt returns the value of the "land_at" field in the mutation.
func (m *FlightMutation) LandAt() (r time.Time, exists bool) {
	v := m.land_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLandAt returns the old "land_at" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldLandAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLandAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLandAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLandAt: %w", err)
	}
	return oldValue.LandAt, nil
}

// ResetLandAt resets all changes to the "land_at" field.
func (m *FlightMutation) ResetLandAt() {
	m.land_at = nil
}

// SetAvailableEcSlot sets the "available_ec_slot" field.
func (m *FlightMutation) SetAvailableEcSlot(i int) {
	m.available_ec_slot = &i
	m.addavailable_ec_slot = nil
}

// AvailableEcSlot returns the value of the "available_ec_slot" field in the mutation.
func (m *FlightMutation) AvailableEcSlot() (r int, exists bool) {
	v := m.available_ec_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableEcSlot returns the old "available_ec_slot" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldAvailableEcSlot(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableEcSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableEcSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableEcSlot: %w", err)
	}
	return oldValue.AvailableEcSlot, nil
}

// AddAvailableEcSlot adds i to the "available_ec_slot" field.
func (m *FlightMutation) AddAvailableEcSlot(i int) {
	if m.addavailable_ec_slot != nil {
		*m.addavailable_ec_slot += i
	} else {
		m.addavailable_ec_slot = &i
	}
}

// AddedAvailableEcSlot returns the value that was added to the "available_ec_slot" field in this mutation.
func (m *FlightMutation) AddedAvailableEcSlot() (r int, exists bool) {
	v := m.addavailable_ec_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableEcSlot resets all changes to the "available_ec_slot" field.
func (m *FlightMutation) ResetAvailableEcSlot() {
	m.available_ec_slot = nil
	m.addavailable_ec_slot = nil
}

// SetAvailableBcSlot sets the "available_bc_slot" field.
func (m *FlightMutation) SetAvailableBcSlot(i int) {
	m.available_bc_slot = &i
	m.addavailable_bc_slot = nil
}

// AvailableBcSlot returns the value of the "available_bc_slot" field in the mutation.
func (m *FlightMutation) AvailableBcSlot() (r int, exists bool) {
	v := m.available_bc_slot
	if v == nil {
		return
	}
	return *v, true
}

// OldAvailableBcSlot returns the old "available_bc_slot" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldAvailableBcSlot(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvailableBcSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvailableBcSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvailableBcSlot: %w", err)
	}
	return oldValue.AvailableBcSlot, nil
}

// AddAvailableBcSlot adds i to the "available_bc_slot" field.
func (m *FlightMutation) AddAvailableBcSlot(i int) {
	if m.addavailable_bc_slot != nil {
		*m.addavailable_bc_slot += i
	} else {
		m.addavailable_bc_slot = &i
	}
}

// AddedAvailableBcSlot returns the value that was added to the "available_bc_slot" field in this mutation.
func (m *FlightMutation) AddedAvailableBcSlot() (r int, exists bool) {
	v := m.addavailable_bc_slot
	if v == nil {
		return
	}
	return *v, true
}

// ResetAvailableBcSlot resets all changes to the "available_bc_slot" field.
func (m *FlightMutation) ResetAvailableBcSlot() {
	m.available_bc_slot = nil
	m.addavailable_bc_slot = nil
}

// SetStatus sets the "status" field.
func (m *FlightMutation) SetStatus(f flight.Status) {
	m.status = &f
}

// Status returns the value of the "status" field in the mutation.
func (m *FlightMutation) Status() (r flight.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldStatus(ctx context.Context) (v flight.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *FlightMutation) ResetStatus() {
	m.status = nil
}

// SetPlaneID sets the "plane_id" field.
func (m *FlightMutation) SetPlaneID(i int) {
	m.has_plane = &i
}

// PlaneID returns the value of the "plane_id" field in the mutation.
func (m *FlightMutation) PlaneID() (r int, exists bool) {
	v := m.has_plane
	if v == nil {
		return
	}
	return *v, true
}

// OldPlaneID returns the old "plane_id" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldPlaneID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlaneID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlaneID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlaneID: %w", err)
	}
	return oldValue.PlaneID, nil
}

// ClearPlaneID clears the value of the "plane_id" field.
func (m *FlightMutation) ClearPlaneID() {
	m.has_plane = nil
	m.clearedFields[flight.FieldPlaneID] = struct{}{}
}

// PlaneIDCleared returns if the "plane_id" field was cleared in this mutation.
func (m *FlightMutation) PlaneIDCleared() bool {
	_, ok := m.clearedFields[flight.FieldPlaneID]
	return ok
}

// ResetPlaneID resets all changes to the "plane_id" field.
func (m *FlightMutation) ResetPlaneID() {
	m.has_plane = nil
	delete(m.clearedFields, flight.FieldPlaneID)
}

// SetFromAirportID sets the "from_airport_id" field.
func (m *FlightMutation) SetFromAirportID(i int) {
	m.from_airport = &i
}

// FromAirportID returns the value of the "from_airport_id" field in the mutation.
func (m *FlightMutation) FromAirportID() (r int, exists bool) {
	v := m.from_airport
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAirportID returns the old "from_airport_id" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldFromAirportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromAirportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromAirportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAirportID: %w", err)
	}
	return oldValue.FromAirportID, nil
}

// ClearFromAirportID clears the value of the "from_airport_id" field.
func (m *FlightMutation) ClearFromAirportID() {
	m.from_airport = nil
	m.clearedFields[flight.FieldFromAirportID] = struct{}{}
}

// FromAirportIDCleared returns if the "from_airport_id" field was cleared in this mutation.
func (m *FlightMutation) FromAirportIDCleared() bool {
	_, ok := m.clearedFields[flight.FieldFromAirportID]
	return ok
}

// ResetFromAirportID resets all changes to the "from_airport_id" field.
func (m *FlightMutation) ResetFromAirportID() {
	m.from_airport = nil
	delete(m.clearedFields, flight.FieldFromAirportID)
}

// SetToAirportID sets the "to_airport_id" field.
func (m *FlightMutation) SetToAirportID(i int) {
	m.to_airport = &i
}

// ToAirportID returns the value of the "to_airport_id" field in the mutation.
func (m *FlightMutation) ToAirportID() (r int, exists bool) {
	v := m.to_airport
	if v == nil {
		return
	}
	return *v, true
}

// OldToAirportID returns the old "to_airport_id" field's value of the Flight entity.
// If the Flight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlightMutation) OldToAirportID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToAirportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToAirportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAirportID: %w", err)
	}
	return oldValue.ToAirportID, nil
}

// ClearToAirportID clears the value of the "to_airport_id" field.
func (m *FlightMutation) ClearToAirportID() {
	m.to_airport = nil
	m.clearedFields[flight.FieldToAirportID] = struct{}{}
}

// ToAirportIDCleared returns if the "to_airport_id" field was cleared in this mutation.
func (m *FlightMutation) ToAirportIDCleared() bool {
	_, ok := m.clearedFields[flight.FieldToAirportID]
	return ok
}

// ResetToAirportID resets all changes to the "to_airport_id" field.
func (m *FlightMutation) ResetToAirportID() {
	m.to_airport = nil
	delete(m.clearedFields, flight.FieldToAirportID)
}

// SetHasPlaneID sets the "has_plane" edge to the Plane entity by id.
func (m *FlightMutation) SetHasPlaneID(id int) {
	m.has_plane = &id
}

// ClearHasPlane clears the "has_plane" edge to the Plane entity.
func (m *FlightMutation) ClearHasPlane() {
	m.clearedhas_plane = true
}

// HasPlaneCleared reports if the "has_plane" edge to the Plane entity was cleared.
func (m *FlightMutation) HasPlaneCleared() bool {
	return m.PlaneIDCleared() || m.clearedhas_plane
}

// HasPlaneID returns the "has_plane" edge ID in the mutation.
func (m *FlightMutation) HasPlaneID() (id int, exists bool) {
	if m.has_plane != nil {
		return *m.has_plane, true
	}
	return
}

// HasPlaneIDs returns the "has_plane" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HasPlaneID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) HasPlaneIDs() (ids []int) {
	if id := m.has_plane; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasPlane resets all changes to the "has_plane" edge.
func (m *FlightMutation) ResetHasPlane() {
	m.has_plane = nil
	m.clearedhas_plane = false
}

// AddHasBookingIDs adds the "has_booking" edge to the Booking entity by ids.
func (m *FlightMutation) AddHasBookingIDs(ids ...int) {
	if m.has_booking == nil {
		m.has_booking = make(map[int]struct{})
	}
	for i := range ids {
		m.has_booking[ids[i]] = struct{}{}
	}
}

// ClearHasBooking clears the "has_booking" edge to the Booking entity.
func (m *FlightMutation) ClearHasBooking() {
	m.clearedhas_booking = true
}

// HasBookingCleared reports if the "has_booking" edge to the Booking entity was cleared.
func (m *FlightMutation) HasBookingCleared() bool {
	return m.clearedhas_booking
}

// RemoveHasBookingIDs removes the "has_booking" edge to the Booking entity by IDs.
func (m *FlightMutation) RemoveHasBookingIDs(ids ...int) {
	if m.removedhas_booking == nil {
		m.removedhas_booking = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.has_booking, ids[i])
		m.removedhas_booking[ids[i]] = struct{}{}
	}
}

// RemovedHasBooking returns the removed IDs of the "has_booking" edge to the Booking entity.
func (m *FlightMutation) RemovedHasBookingIDs() (ids []int) {
	for id := range m.removedhas_booking {
		ids = append(ids, id)
	}
	return
}

// HasBookingIDs returns the "has_booking" edge IDs in the mutation.
func (m *FlightMutation) HasBookingIDs() (ids []int) {
	for id := range m.has_booking {
		ids = append(ids, id)
	}
	return
}

// ResetHasBooking resets all changes to the "has_booking" edge.
func (m *FlightMutation) ResetHasBooking() {
	m.has_booking = nil
	m.clearedhas_booking = false
	m.removedhas_booking = nil
}

// ClearFromAirport clears the "from_airport" edge to the Airport entity.
func (m *FlightMutation) ClearFromAirport() {
	m.clearedfrom_airport = true
}

// FromAirportCleared reports if the "from_airport" edge to the Airport entity was cleared.
func (m *FlightMutation) FromAirportCleared() bool {
	return m.FromAirportIDCleared() || m.clearedfrom_airport
}

// FromAirportIDs returns the "from_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromAirportID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) FromAirportIDs() (ids []int) {
	if id := m.from_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromAirport resets all changes to the "from_airport" edge.
func (m *FlightMutation) ResetFromAirport() {
	m.from_airport = nil
	m.clearedfrom_airport = false
}

// ClearToAirport clears the "to_airport" edge to the Airport entity.
func (m *FlightMutation) ClearToAirport() {
	m.clearedto_airport = true
}

// ToAirportCleared reports if the "to_airport" edge to the Airport entity was cleared.
func (m *FlightMutation) ToAirportCleared() bool {
	return m.ToAirportIDCleared() || m.clearedto_airport
}

// ToAirportIDs returns the "to_airport" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToAirportID instead. It exists only for internal usage by the builders.
func (m *FlightMutation) ToAirportIDs() (ids []int) {
	if id := m.to_airport; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetToAirport resets all changes to the "to_airport" edge.
func (m *FlightMutation) ResetToAirport() {
	m.to_airport = nil
	m.clearedto_airport = false
}

// Where appends a list predicates to the FlightMutation builder.
func (m *FlightMutation) Where(ps ...predicate.Flight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FlightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FlightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Flight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FlightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FlightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Flight).
func (m *FlightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlightMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, flight.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, flight.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, flight.FieldName)
	}
	if m.depart_at != nil {
		fields = append(fields, flight.FieldDepartAt)
	}
	if m.land_at != nil {
		fields = append(fields, flight.FieldLandAt)
	}
	if m.available_ec_slot != nil {
		fields = append(fields, flight.FieldAvailableEcSlot)
	}
	if m.available_bc_slot != nil {
		fields = append(fields, flight.FieldAvailableBcSlot)
	}
	if m.status != nil {
		fields = append(fields, flight.FieldStatus)
	}
	if m.has_plane != nil {
		fields = append(fields, flight.FieldPlaneID)
	}
	if m.from_airport != nil {
		fields = append(fields, flight.FieldFromAirportID)
	}
	if m.to_airport != nil {
		fields = append(fields, flight.FieldToAirportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldCreatedAt:
		return m.CreatedAt()
	case flight.FieldUpdatedAt:
		return m.UpdatedAt()
	case flight.FieldName:
		return m.Name()
	case flight.FieldDepartAt:
		return m.DepartAt()
	case flight.FieldLandAt:
		return m.LandAt()
	case flight.FieldAvailableEcSlot:
		return m.AvailableEcSlot()
	case flight.FieldAvailableBcSlot:
		return m.AvailableBcSlot()
	case flight.FieldStatus:
		return m.Status()
	case flight.FieldPlaneID:
		return m.PlaneID()
	case flight.FieldFromAirportID:
		return m.FromAirportID()
	case flight.FieldToAirportID:
		return m.ToAirportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flight.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case flight.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case flight.FieldName:
		return m.OldName(ctx)
	case flight.FieldDepartAt:
		return m.OldDepartAt(ctx)
	case flight.FieldLandAt:
		return m.OldLandAt(ctx)
	case flight.FieldAvailableEcSlot:
		return m.OldAvailableEcSlot(ctx)
	case flight.FieldAvailableBcSlot:
		return m.OldAvailableBcSlot(ctx)
	case flight.FieldStatus:
		return m.OldStatus(ctx)
	case flight.FieldPlaneID:
		return m.OldPlaneID(ctx)
	case flight.FieldFromAirportID:
		return m.OldFromAirportID(ctx)
	case flight.FieldToAirportID:
		return m.OldToAirportID(ctx)
	}
	return nil, fmt.Errorf("unknown Flight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flight.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case flight.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case flight.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case flight.FieldDepartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartAt(v)
		return nil
	case flight.FieldLandAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLandAt(v)
		return nil
	case flight.FieldAvailableEcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableEcSlot(v)
		return nil
	case flight.FieldAvailableBcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvailableBcSlot(v)
		return nil
	case flight.FieldStatus:
		v, ok := value.(flight.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case flight.FieldPlaneID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlaneID(v)
		return nil
	case flight.FieldFromAirportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAirportID(v)
		return nil
	case flight.FieldToAirportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAirportID(v)
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlightMutation) AddedFields() []string {
	var fields []string
	if m.addavailable_ec_slot != nil {
		fields = append(fields, flight.FieldAvailableEcSlot)
	}
	if m.addavailable_bc_slot != nil {
		fields = append(fields, flight.FieldAvailableBcSlot)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlightMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case flight.FieldAvailableEcSlot:
		return m.AddedAvailableEcSlot()
	case flight.FieldAvailableBcSlot:
		return m.AddedAvailableBcSlot()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlightMutation) AddField(name string, value ent.Value) error {
	switch name {
	case flight.FieldAvailableEcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableEcSlot(v)
		return nil
	case flight.FieldAvailableBcSlot:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAvailableBcSlot(v)
		return nil
	}
	return fmt.Errorf("unknown Flight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlightMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(flight.FieldPlaneID) {
		fields = append(fields, flight.FieldPlaneID)
	}
	if m.FieldCleared(flight.FieldFromAirportID) {
		fields = append(fields, flight.FieldFromAirportID)
	}
	if m.FieldCleared(flight.FieldToAirportID) {
		fields = append(fields, flight.FieldToAirportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlightMutation) ClearField(name string) error {
	switch name {
	case flight.FieldPlaneID:
		m.ClearPlaneID()
		return nil
	case flight.FieldFromAirportID:
		m.ClearFromAirportID()
		return nil
	case flight.FieldToAirportID:
		m.ClearToAirportID()
		return nil
	}
	return fmt.Errorf("unknown Flight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlightMutation) ResetField(name string) error {
	switch name {
	case flight.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case flight.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case flight.FieldName:
		m.ResetName()
		return nil
	case flight.FieldDepartAt:
		m.ResetDepartAt()
		return nil
	case flight.FieldLandAt:
		m.ResetLandAt()
		return nil
	case flight.FieldAvailableEcSlot:
		m.ResetAvailableEcSlot()
		return nil
	case flight.FieldAvailableBcSlot:
		m.ResetAvailableBcSlot()
		return nil
	case flight.FieldStatus:
		m.ResetStatus()
		return nil
	case flight.FieldPlaneID:
		m.ResetPlaneID()
		return nil
	case flight.FieldFromAirportID:
		m.ResetFromAirportID()
		return nil
	case flight.FieldToAirportID:
		m.ResetToAirportID()
		return nil
	}
	return fmt.Errorf("unknown Flight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlightMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.has_plane != nil {
		edges = append(edges, flight.EdgeHasPlane)
	}
	if m.has_booking != nil {
		edges = append(edges, flight.EdgeHasBooking)
	}
	if m.from_airport != nil {
		edges = append(edges, flight.EdgeFromAirport)
	}
	if m.to_airport != nil {
		edges = append(edges, flight.EdgeToAirport)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeHasPlane:
		if id := m.has_plane; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeHasBooking:
		ids := make([]ent.Value, 0, len(m.has_booking))
		for id := range m.has_booking {
			ids = append(ids, id)
		}
		return ids
	case flight.EdgeFromAirport:
		if id := m.from_airport; id != nil {
			return []ent.Value{*id}
		}
	case flight.EdgeToAirport:
		if id := m.to_airport; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedhas_booking != nil {
		edges = append(edges, flight.EdgeHasBooking)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlightMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flight.EdgeHasBooking:
		ids := make([]ent.Value, 0, len(m.removedhas_booking))
		for id := range m.removedhas_booking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedhas_plane {
		edges = append(edges, flight.EdgeHasPlane)
	}
	if m.clearedhas_booking {
		edges = append(edges, flight.EdgeHasBooking)
	}
	if m.clearedfrom_airport {
		edges = append(edges, flight.EdgeFromAirport)
	}
	if m.clearedto_airport {
		edges = append(edges, flight.EdgeToAirport)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlightMutation) EdgeCleared(name string) bool {
	switch name {
	case flight.EdgeHasPlane:
		return m.clearedhas_plane
	case flight.EdgeHasBooking:
		return m.clearedhas_booking
	case flight.EdgeFromAirport:
		return m.clearedfrom_airport
	case flight.EdgeToAirport:
		return m.clearedto_airport
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlightMutation) ClearEdge(name string) error {
	switch name {
	case flight.EdgeHasPlane:
		m.ClearHasPlane()
		return nil
	case flight.EdgeFromAirport:
		m.ClearFromAirport()
		return nil
	case flight.EdgeToAirport:
		m.ClearToAirport()
		return nil
	}
	return fmt.Errorf("unknown Flight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlightMutation) ResetEdge(name string) error {
	switch name {
	case flight.EdgeHasPlane:
		m.ResetHasPlane()
		return nil
	case flight.EdgeHasBooking:
		m.ResetHasBooking()
		return nil
	case flight.EdgeFromAirport:
		m.ResetFromAirport()
		return nil
	case flight.EdgeToAirport:
		m.ResetToAirport()
		return nil
	}
	return fmt.Errorf("unknown Flight edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	created_at          *time.Time
	updated_at          *time.Time
	email               *string
	password            *string
	phone_number        *string
	full_name           *string
	dob                 *time.Time
	cid                 *string
	member_type         *member.MemberType
	clearedFields       map[string]struct{}
	has_customer        *int
	clearedhas_customer bool
	done                bool
	oldValue            func(context.Context) (*Member, error)
	predicates          []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id int) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MemberMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MemberMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MemberMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MemberMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MemberMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MemberMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEmail sets the "email" field.
func (m *MemberMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *MemberMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *MemberMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *MemberMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MemberMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *MemberMutation) ResetPassword() {
	m.password = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *MemberMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *MemberMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *MemberMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetFullName sets the "full_name" field.
func (m *MemberMutation) SetFullName(s string) {
	m.full_name = &s
}

// FullName returns the value of the "full_name" field in the mutation.
func (m *MemberMutation) FullName() (r string, exists bool) {
	v := m.full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFullName returns the old "full_name" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFullName: %w", err)
	}
	return oldValue.FullName, nil
}

// ResetFullName resets all changes to the "full_name" field.
func (m *MemberMutation) ResetFullName() {
	m.full_name = nil
}

// SetDob sets the "dob" field.
func (m *MemberMutation) SetDob(t time.Time) {
	m.dob = &t
}

// Dob returns the value of the "dob" field in the mutation.
func (m *MemberMutation) Dob() (r time.Time, exists bool) {
	v := m.dob
	if v == nil {
		return
	}
	return *v, true
}

// OldDob returns the old "dob" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldDob(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDob is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDob requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDob: %w", err)
	}
	return oldValue.Dob, nil
}

// ClearDob clears the value of the "dob" field.
func (m *MemberMutation) ClearDob() {
	m.dob = nil
	m.clearedFields[member.FieldDob] = struct{}{}
}

// DobCleared returns if the "dob" field was cleared in this mutation.
func (m *MemberMutation) DobCleared() bool {
	_, ok := m.clearedFields[member.FieldDob]
	return ok
}

// ResetDob resets all changes to the "dob" field.
func (m *MemberMutation) ResetDob() {
	m.dob = nil
	delete(m.clearedFields, member.FieldDob)
}

// SetCid sets the "cid" field.
func (m *MemberMutation) SetCid(s string) {
	m.cid = &s
}

// Cid returns the value of the "cid" field in the mutation.
func (m *MemberMutation) Cid() (r string, exists bool) {
	v := m.cid
	if v == nil {
		return
	}
	return *v, true
}

// OldCid returns the old "cid" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldCid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCid: %w", err)
	}
	return oldValue.Cid, nil
}

// ResetCid resets all changes to the "cid" field.
func (m *MemberMutation) ResetCid() {
	m.cid = nil
}

// SetMemberType sets the "member_type" field.
func (m *MemberMutation) SetMemberType(mt member.MemberType) {
	m.member_type = &mt
}

// MemberType returns the value of the "member_type" field in the mutation.
func (m *MemberMutation) MemberType() (r member.MemberType, exists bool) {
	v := m.member_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberType returns the old "member_type" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMemberType(ctx context.Context) (v member.MemberType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberType: %w", err)
	}
	return oldValue.MemberType, nil
}

// ClearMemberType clears the value of the "member_type" field.
func (m *MemberMutation) ClearMemberType() {
	m.member_type = nil
	m.clearedFields[member.FieldMemberType] = struct{}{}
}

// MemberTypeCleared returns if the "member_type" field was cleared in this mutation.
func (m *MemberMutation) MemberTypeCleared() bool {
	_, ok := m.clearedFields[member.FieldMemberType]
	return ok
}

// ResetMemberType resets all changes to the "member_type" field.
func (m *MemberMutation) ResetMemberType() {
	m.member_type = nil
	delete(m.clearedFields, member.FieldMemberType)
}

// SetHasCustomerID sets the "has_customer" edge to the Customer entity by id.
func (m *MemberMutation) SetHasCustomerID(id int) {
	m.has_customer = &id
}

// ClearHasCustomer clears the "has_customer" edge to the Customer entity.
func (m *MemberMutation) ClearHasCustomer() {
	m.clearedhas_customer = true
}

// HasCustomerCleared reports if the "has_customer" edge to the Customer entity was cleared.
func (m *MemberMutation) HasCustomerCleared() bool {
	return m.clearedhas_customer
}

// HasCustomerID returns the "has_customer" edge ID in the mutation.
func (m *MemberMutation) HasCustomerID() (id int, exists bool) {
	if m.has_customer != nil {
		return *m.has_customer, true
	}
	return
}

// HasCustomerIDs returns the "has_customer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HasCustomerID instead. It exists only for internal usage by the builders.
func (m *MemberMutation) HasCustomerIDs() (ids []int) {
	if id := m.has_customer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHasCustomer resets all changes to the "has_customer" edge.
func (m *MemberMutation) ResetHasCustomer() {
	m.has_customer = nil
	m.clearedhas_customer = false
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, member.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, member.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, member.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, member.FieldPassword)
	}
	if m.phone_number != nil {
		fields = append(fields, member.FieldPhoneNumber)
	}
	if m.full_name != nil {
		fields = append(fields, member.FieldFullName)
	}
	if m.dob != nil {
		fields = append(fields, member.FieldDob)
	}
	if m.cid != nil {
		fields = append(fields, member.FieldCid)
	}
	if m.member_type != nil {
		fields = append(fields, member.FieldMemberType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldCreatedAt:
		return m.CreatedAt()
	case member.FieldUpdatedAt:
		return m.UpdatedAt()
	case member.FieldEmail:
		return m.Email()
	case member.FieldPassword:
		return m.Password()
	case member.FieldPhoneNumber:
		return m.PhoneNumber()
	case member.FieldFullName:
		return m.FullName()
	case member.FieldDob:
		return m.Dob()
	case member.FieldCid:
		return m.Cid()
	case member.FieldMemberType:
		return m.MemberType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case member.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case member.FieldEmail:
		return m.OldEmail(ctx)
	case member.FieldPassword:
		return m.OldPassword(ctx)
	case member.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case member.FieldFullName:
		return m.OldFullName(ctx)
	case member.FieldDob:
		return m.OldDob(ctx)
	case member.FieldCid:
		return m.OldCid(ctx)
	case member.FieldMemberType:
		return m.OldMemberType(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case member.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case member.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case member.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case member.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case member.FieldFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFullName(v)
		return nil
	case member.FieldDob:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDob(v)
		return nil
	case member.FieldCid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCid(v)
		return nil
	case member.FieldMemberType:
		v, ok := value.(member.MemberType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberType(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(member.FieldDob) {
		fields = append(fields, member.FieldDob)
	}
	if m.FieldCleared(member.FieldMemberType) {
		fields = append(fields, member.FieldMemberType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	switch name {
	case member.FieldDob:
		m.ClearDob()
		return nil
	case member.FieldMemberType:
		m.ClearMemberType()
		return nil
	}
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case member.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case member.FieldEmail:
		m.ResetEmail()
		return nil
	case member.FieldPassword:
		m.ResetPassword()
		return nil
	case member.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case member.FieldFullName:
		m.ResetFullName()
		return nil
	case member.FieldDob:
		m.ResetDob()
		return nil
	case member.FieldCid:
		m.ResetCid()
		return nil
	case member.FieldMemberType:
		m.ResetMemberType()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.has_customer != nil {
		edges = append(edges, member.EdgeHasCustomer)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeHasCustomer:
		if id := m.has_customer; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhas_customer {
		edges = append(edges, member.EdgeHasCustomer)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeHasCustomer:
		return m.clearedhas_customer
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	case member.EdgeHasCustomer:
		m.ClearHasCustomer()
		return nil
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeHasCustomer:
		m.ResetHasCustomer()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// PlaneMutation represents an operation that mutates the Plane nodes in the graph.
type PlaneMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	created_at              *time.Time
	updated_at              *time.Time
	name                    *string
	economy_class_slots     *int64
	addeconomy_class_slots  *int64
	business_class_slots    *int64
	addbusiness_class_slots *int64
	status                  *plane.Status
	clearedFields           map[string]struct{}
	flights                 map[int]struct{}
	removedflights          map[int]struct{}
	clearedflights          bool
	done                    bool
	oldValue                func(context.Context) (*Plane, error)
	predicates              []predicate.Plane
}

var _ ent.Mutation = (*PlaneMutation)(nil)

// planeOption allows management of the mutation configuration using functional options.
type planeOption func(*PlaneMutation)

// newPlaneMutation creates new mutation for the Plane entity.
func newPlaneMutation(c config, op Op, opts ...planeOption) *PlaneMutation {
	m := &PlaneMutation{
		config:        c,
		op:            op,
		typ:           TypePlane,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlaneID sets the ID field of the mutation.
func withPlaneID(id int) planeOption {
	return func(m *PlaneMutation) {
		var (
			err   error
			once  sync.Once
			value *Plane
		)
		m.oldValue = func(ctx context.Context) (*Plane, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plane.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlane sets the old Plane of the mutation.
func withPlane(node *Plane) planeOption {
	return func(m *PlaneMutation) {
		m.oldValue = func(context.Context) (*Plane, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlaneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlaneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlaneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlaneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plane.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlaneMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlaneMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlaneMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlaneMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlaneMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlaneMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *PlaneMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlaneMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PlaneMutation) ResetName() {
	m.name = nil
}

// SetEconomyClassSlots sets the "economy_class_slots" field.
func (m *PlaneMutation) SetEconomyClassSlots(i int64) {
	m.economy_class_slots = &i
	m.addeconomy_class_slots = nil
}

// EconomyClassSlots returns the value of the "economy_class_slots" field in the mutation.
func (m *PlaneMutation) EconomyClassSlots() (r int64, exists bool) {
	v := m.economy_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// OldEconomyClassSlots returns the old "economy_class_slots" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldEconomyClassSlots(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEconomyClassSlots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEconomyClassSlots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEconomyClassSlots: %w", err)
	}
	return oldValue.EconomyClassSlots, nil
}

// AddEconomyClassSlots adds i to the "economy_class_slots" field.
func (m *PlaneMutation) AddEconomyClassSlots(i int64) {
	if m.addeconomy_class_slots != nil {
		*m.addeconomy_class_slots += i
	} else {
		m.addeconomy_class_slots = &i
	}
}

// AddedEconomyClassSlots returns the value that was added to the "economy_class_slots" field in this mutation.
func (m *PlaneMutation) AddedEconomyClassSlots() (r int64, exists bool) {
	v := m.addeconomy_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// ResetEconomyClassSlots resets all changes to the "economy_class_slots" field.
func (m *PlaneMutation) ResetEconomyClassSlots() {
	m.economy_class_slots = nil
	m.addeconomy_class_slots = nil
}

// SetBusinessClassSlots sets the "business_class_slots" field.
func (m *PlaneMutation) SetBusinessClassSlots(i int64) {
	m.business_class_slots = &i
	m.addbusiness_class_slots = nil
}

// BusinessClassSlots returns the value of the "business_class_slots" field in the mutation.
func (m *PlaneMutation) BusinessClassSlots() (r int64, exists bool) {
	v := m.business_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessClassSlots returns the old "business_class_slots" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldBusinessClassSlots(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBusinessClassSlots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBusinessClassSlots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessClassSlots: %w", err)
	}
	return oldValue.BusinessClassSlots, nil
}

// AddBusinessClassSlots adds i to the "business_class_slots" field.
func (m *PlaneMutation) AddBusinessClassSlots(i int64) {
	if m.addbusiness_class_slots != nil {
		*m.addbusiness_class_slots += i
	} else {
		m.addbusiness_class_slots = &i
	}
}

// AddedBusinessClassSlots returns the value that was added to the "business_class_slots" field in this mutation.
func (m *PlaneMutation) AddedBusinessClassSlots() (r int64, exists bool) {
	v := m.addbusiness_class_slots
	if v == nil {
		return
	}
	return *v, true
}

// ResetBusinessClassSlots resets all changes to the "business_class_slots" field.
func (m *PlaneMutation) ResetBusinessClassSlots() {
	m.business_class_slots = nil
	m.addbusiness_class_slots = nil
}

// SetStatus sets the "status" field.
func (m *PlaneMutation) SetStatus(pl plane.Status) {
	m.status = &pl
}

// Status returns the value of the "status" field in the mutation.
func (m *PlaneMutation) Status() (r plane.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Plane entity.
// If the Plane object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlaneMutation) OldStatus(ctx context.Context) (v plane.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PlaneMutation) ResetStatus() {
	m.status = nil
}

// AddFlightIDs adds the "flights" edge to the Flight entity by ids.
func (m *PlaneMutation) AddFlightIDs(ids ...int) {
	if m.flights == nil {
		m.flights = make(map[int]struct{})
	}
	for i := range ids {
		m.flights[ids[i]] = struct{}{}
	}
}

// ClearFlights clears the "flights" edge to the Flight entity.
func (m *PlaneMutation) ClearFlights() {
	m.clearedflights = true
}

// FlightsCleared reports if the "flights" edge to the Flight entity was cleared.
func (m *PlaneMutation) FlightsCleared() bool {
	return m.clearedflights
}

// RemoveFlightIDs removes the "flights" edge to the Flight entity by IDs.
func (m *PlaneMutation) RemoveFlightIDs(ids ...int) {
	if m.removedflights == nil {
		m.removedflights = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flights, ids[i])
		m.removedflights[ids[i]] = struct{}{}
	}
}

// RemovedFlights returns the removed IDs of the "flights" edge to the Flight entity.
func (m *PlaneMutation) RemovedFlightsIDs() (ids []int) {
	for id := range m.removedflights {
		ids = append(ids, id)
	}
	return
}

// FlightsIDs returns the "flights" edge IDs in the mutation.
func (m *PlaneMutation) FlightsIDs() (ids []int) {
	for id := range m.flights {
		ids = append(ids, id)
	}
	return
}

// ResetFlights resets all changes to the "flights" edge.
func (m *PlaneMutation) ResetFlights() {
	m.flights = nil
	m.clearedflights = false
	m.removedflights = nil
}

// Where appends a list predicates to the PlaneMutation builder.
func (m *PlaneMutation) Where(ps ...predicate.Plane) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlaneMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlaneMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plane, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlaneMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlaneMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plane).
func (m *PlaneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlaneMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, plane.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plane.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, plane.FieldName)
	}
	if m.economy_class_slots != nil {
		fields = append(fields, plane.FieldEconomyClassSlots)
	}
	if m.business_class_slots != nil {
		fields = append(fields, plane.FieldBusinessClassSlots)
	}
	if m.status != nil {
		fields = append(fields, plane.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlaneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plane.FieldCreatedAt:
		return m.CreatedAt()
	case plane.FieldUpdatedAt:
		return m.UpdatedAt()
	case plane.FieldName:
		return m.Name()
	case plane.FieldEconomyClassSlots:
		return m.EconomyClassSlots()
	case plane.FieldBusinessClassSlots:
		return m.BusinessClassSlots()
	case plane.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlaneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plane.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plane.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plane.FieldName:
		return m.OldName(ctx)
	case plane.FieldEconomyClassSlots:
		return m.OldEconomyClassSlots(ctx)
	case plane.FieldBusinessClassSlots:
		return m.OldBusinessClassSlots(ctx)
	case plane.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Plane field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plane.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plane.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plane.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plane.FieldEconomyClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEconomyClassSlots(v)
		return nil
	case plane.FieldBusinessClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessClassSlots(v)
		return nil
	case plane.FieldStatus:
		v, ok := value.(plane.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Plane field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlaneMutation) AddedFields() []string {
	var fields []string
	if m.addeconomy_class_slots != nil {
		fields = append(fields, plane.FieldEconomyClassSlots)
	}
	if m.addbusiness_class_slots != nil {
		fields = append(fields, plane.FieldBusinessClassSlots)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlaneMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plane.FieldEconomyClassSlots:
		return m.AddedEconomyClassSlots()
	case plane.FieldBusinessClassSlots:
		return m.AddedBusinessClassSlots()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlaneMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plane.FieldEconomyClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEconomyClassSlots(v)
		return nil
	case plane.FieldBusinessClassSlots:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBusinessClassSlots(v)
		return nil
	}
	return fmt.Errorf("unknown Plane numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlaneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlaneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlaneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Plane nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlaneMutation) ResetField(name string) error {
	switch name {
	case plane.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plane.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plane.FieldName:
		m.ResetName()
		return nil
	case plane.FieldEconomyClassSlots:
		m.ResetEconomyClassSlots()
		return nil
	case plane.FieldBusinessClassSlots:
		m.ResetBusinessClassSlots()
		return nil
	case plane.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Plane field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlaneMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.flights != nil {
		edges = append(edges, plane.EdgeFlights)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlaneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plane.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.flights))
		for id := range m.flights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlaneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedflights != nil {
		edges = append(edges, plane.EdgeFlights)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlaneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plane.EdgeFlights:
		ids := make([]ent.Value, 0, len(m.removedflights))
		for id := range m.removedflights {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlaneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedflights {
		edges = append(edges, plane.EdgeFlights)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlaneMutation) EdgeCleared(name string) bool {
	switch name {
	case plane.EdgeFlights:
		return m.clearedflights
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlaneMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plane unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlaneMutation) ResetEdge(name string) error {
	switch name {
	case plane.EdgeFlights:
		m.ResetFlights()
		return nil
	}
	return fmt.Errorf("unknown Plane edge %s", name)
}
