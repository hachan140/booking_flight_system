// Code generated by ent, DO NOT EDIT.

package ent

import (
	"booking-flight-system/ent/airport"
	"booking-flight-system/ent/booking"
	"booking-flight-system/ent/customer"
	"booking-flight-system/ent/flight"
	"booking-flight-system/ent/member"
	"booking-flight-system/ent/plane"
	"booking-flight-system/ent/predicate"
	"errors"
	"fmt"
	"time"
)

// AirportWhereInput represents a where input for filtering Airport queries.
type AirportWhereInput struct {
	Predicates []predicate.Airport  `json:"-"`
	Not        *AirportWhereInput   `json:"not,omitempty"`
	Or         []*AirportWhereInput `json:"or,omitempty"`
	And        []*AirportWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "lat" field predicates.
	Lat      *float64  `json:"lat,omitempty"`
	LatNEQ   *float64  `json:"latNEQ,omitempty"`
	LatIn    []float64 `json:"latIn,omitempty"`
	LatNotIn []float64 `json:"latNotIn,omitempty"`
	LatGT    *float64  `json:"latGT,omitempty"`
	LatGTE   *float64  `json:"latGTE,omitempty"`
	LatLT    *float64  `json:"latLT,omitempty"`
	LatLTE   *float64  `json:"latLTE,omitempty"`

	// "long" field predicates.
	Long      *float64  `json:"long,omitempty"`
	LongNEQ   *float64  `json:"longNEQ,omitempty"`
	LongIn    []float64 `json:"longIn,omitempty"`
	LongNotIn []float64 `json:"longNotIn,omitempty"`
	LongGT    *float64  `json:"longGT,omitempty"`
	LongGTE   *float64  `json:"longGTE,omitempty"`
	LongLT    *float64  `json:"longLT,omitempty"`
	LongLTE   *float64  `json:"longLTE,omitempty"`

	// "has_flight" edge predicates.
	HasHasFlight     *bool               `json:"hasHasFlight,omitempty"`
	HasHasFlightWith []*FlightWhereInput `json:"hasHasFlightWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AirportWhereInput) AddPredicates(predicates ...predicate.Airport) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AirportWhereInput filter on the AirportQuery builder.
func (i *AirportWhereInput) Filter(q *AirportQuery) (*AirportQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAirportWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAirportWhereInput is returned in case the AirportWhereInput is empty.
var ErrEmptyAirportWhereInput = errors.New("ent: empty predicate AirportWhereInput")

// P returns a predicate for filtering airports.
// An error is returned if the input is empty or invalid.
func (i *AirportWhereInput) P() (predicate.Airport, error) {
	var predicates []predicate.Airport
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, airport.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Airport, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, airport.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Airport, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, airport.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, airport.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, airport.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, airport.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, airport.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, airport.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, airport.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, airport.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, airport.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, airport.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, airport.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, airport.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, airport.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, airport.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, airport.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, airport.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, airport.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, airport.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, airport.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, airport.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, airport.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, airport.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, airport.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, airport.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, airport.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, airport.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, airport.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, airport.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, airport.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, airport.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, airport.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, airport.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, airport.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, airport.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, airport.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, airport.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, airport.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, airport.NameContainsFold(*i.NameContainsFold))
	}
	if i.Lat != nil {
		predicates = append(predicates, airport.LatEQ(*i.Lat))
	}
	if i.LatNEQ != nil {
		predicates = append(predicates, airport.LatNEQ(*i.LatNEQ))
	}
	if len(i.LatIn) > 0 {
		predicates = append(predicates, airport.LatIn(i.LatIn...))
	}
	if len(i.LatNotIn) > 0 {
		predicates = append(predicates, airport.LatNotIn(i.LatNotIn...))
	}
	if i.LatGT != nil {
		predicates = append(predicates, airport.LatGT(*i.LatGT))
	}
	if i.LatGTE != nil {
		predicates = append(predicates, airport.LatGTE(*i.LatGTE))
	}
	if i.LatLT != nil {
		predicates = append(predicates, airport.LatLT(*i.LatLT))
	}
	if i.LatLTE != nil {
		predicates = append(predicates, airport.LatLTE(*i.LatLTE))
	}
	if i.Long != nil {
		predicates = append(predicates, airport.LongEQ(*i.Long))
	}
	if i.LongNEQ != nil {
		predicates = append(predicates, airport.LongNEQ(*i.LongNEQ))
	}
	if len(i.LongIn) > 0 {
		predicates = append(predicates, airport.LongIn(i.LongIn...))
	}
	if len(i.LongNotIn) > 0 {
		predicates = append(predicates, airport.LongNotIn(i.LongNotIn...))
	}
	if i.LongGT != nil {
		predicates = append(predicates, airport.LongGT(*i.LongGT))
	}
	if i.LongGTE != nil {
		predicates = append(predicates, airport.LongGTE(*i.LongGTE))
	}
	if i.LongLT != nil {
		predicates = append(predicates, airport.LongLT(*i.LongLT))
	}
	if i.LongLTE != nil {
		predicates = append(predicates, airport.LongLTE(*i.LongLTE))
	}

	if i.HasHasFlight != nil {
		p := airport.HasHasFlight()
		if !*i.HasHasFlight {
			p = airport.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasFlightWith) > 0 {
		with := make([]predicate.Flight, 0, len(i.HasHasFlightWith))
		for _, w := range i.HasHasFlightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasFlightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, airport.HasHasFlightWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAirportWhereInput
	case 1:
		return predicates[0], nil
	default:
		return airport.And(predicates...), nil
	}
}

// BookingWhereInput represents a where input for filtering Booking queries.
type BookingWhereInput struct {
	Predicates []predicate.Booking  `json:"-"`
	Not        *BookingWhereInput   `json:"not,omitempty"`
	Or         []*BookingWhereInput `json:"or,omitempty"`
	And        []*BookingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "flight_id" field predicates.
	FlightID       *int  `json:"flightID,omitempty"`
	FlightIDNEQ    *int  `json:"flightIDNEQ,omitempty"`
	FlightIDIn     []int `json:"flightIDIn,omitempty"`
	FlightIDNotIn  []int `json:"flightIDNotIn,omitempty"`
	FlightIDIsNil  bool  `json:"flightIDIsNil,omitempty"`
	FlightIDNotNil bool  `json:"flightIDNotNil,omitempty"`

	// "has_flight" edge predicates.
	HasHasFlight     *bool               `json:"hasHasFlight,omitempty"`
	HasHasFlightWith []*FlightWhereInput `json:"hasHasFlightWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BookingWhereInput) AddPredicates(predicates ...predicate.Booking) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BookingWhereInput filter on the BookingQuery builder.
func (i *BookingWhereInput) Filter(q *BookingQuery) (*BookingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBookingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBookingWhereInput is returned in case the BookingWhereInput is empty.
var ErrEmptyBookingWhereInput = errors.New("ent: empty predicate BookingWhereInput")

// P returns a predicate for filtering bookings.
// An error is returned if the input is empty or invalid.
func (i *BookingWhereInput) P() (predicate.Booking, error) {
	var predicates []predicate.Booking
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, booking.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Booking, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, booking.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Booking, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, booking.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, booking.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, booking.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, booking.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, booking.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, booking.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, booking.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, booking.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, booking.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, booking.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, booking.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, booking.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, booking.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, booking.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, booking.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, booking.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, booking.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, booking.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, booking.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, booking.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, booking.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, booking.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, booking.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, booking.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, booking.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, booking.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, booking.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, booking.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, booking.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, booking.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, booking.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, booking.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, booking.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, booking.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, booking.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, booking.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, booking.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, booking.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, booking.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, booking.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, booking.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, booking.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, booking.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, booking.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, booking.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, booking.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, booking.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, booking.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, booking.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, booking.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, booking.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.FlightID != nil {
		predicates = append(predicates, booking.FlightIDEQ(*i.FlightID))
	}
	if i.FlightIDNEQ != nil {
		predicates = append(predicates, booking.FlightIDNEQ(*i.FlightIDNEQ))
	}
	if len(i.FlightIDIn) > 0 {
		predicates = append(predicates, booking.FlightIDIn(i.FlightIDIn...))
	}
	if len(i.FlightIDNotIn) > 0 {
		predicates = append(predicates, booking.FlightIDNotIn(i.FlightIDNotIn...))
	}
	if i.FlightIDIsNil {
		predicates = append(predicates, booking.FlightIDIsNil())
	}
	if i.FlightIDNotNil {
		predicates = append(predicates, booking.FlightIDNotNil())
	}

	if i.HasHasFlight != nil {
		p := booking.HasHasFlight()
		if !*i.HasHasFlight {
			p = booking.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasFlightWith) > 0 {
		with := make([]predicate.Flight, 0, len(i.HasHasFlightWith))
		for _, w := range i.HasHasFlightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasFlightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, booking.HasHasFlightWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBookingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return booking.And(predicates...), nil
	}
}

// CustomerWhereInput represents a where input for filtering Customer queries.
type CustomerWhereInput struct {
	Predicates []predicate.Customer  `json:"-"`
	Not        *CustomerWhereInput   `json:"not,omitempty"`
	Or         []*CustomerWhereInput `json:"or,omitempty"`
	And        []*CustomerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "dob" field predicates.
	Dob      *time.Time  `json:"dob,omitempty"`
	DobNEQ   *time.Time  `json:"dobNEQ,omitempty"`
	DobIn    []time.Time `json:"dobIn,omitempty"`
	DobNotIn []time.Time `json:"dobNotIn,omitempty"`
	DobGT    *time.Time  `json:"dobGT,omitempty"`
	DobGTE   *time.Time  `json:"dobGTE,omitempty"`
	DobLT    *time.Time  `json:"dobLT,omitempty"`
	DobLTE   *time.Time  `json:"dobLTE,omitempty"`

	// "cid" field predicates.
	Cid             *string  `json:"cid,omitempty"`
	CidNEQ          *string  `json:"cidNEQ,omitempty"`
	CidIn           []string `json:"cidIn,omitempty"`
	CidNotIn        []string `json:"cidNotIn,omitempty"`
	CidGT           *string  `json:"cidGT,omitempty"`
	CidGTE          *string  `json:"cidGTE,omitempty"`
	CidLT           *string  `json:"cidLT,omitempty"`
	CidLTE          *string  `json:"cidLTE,omitempty"`
	CidContains     *string  `json:"cidContains,omitempty"`
	CidHasPrefix    *string  `json:"cidHasPrefix,omitempty"`
	CidHasSuffix    *string  `json:"cidHasSuffix,omitempty"`
	CidEqualFold    *string  `json:"cidEqualFold,omitempty"`
	CidContainsFold *string  `json:"cidContainsFold,omitempty"`

	// "member_id" field predicates.
	MemberID       *int  `json:"memberID,omitempty"`
	MemberIDNEQ    *int  `json:"memberIDNEQ,omitempty"`
	MemberIDIn     []int `json:"memberIDIn,omitempty"`
	MemberIDNotIn  []int `json:"memberIDNotIn,omitempty"`
	MemberIDIsNil  bool  `json:"memberIDIsNil,omitempty"`
	MemberIDNotNil bool  `json:"memberIDNotNil,omitempty"`

	// "has_member" edge predicates.
	HasHasMember     *bool               `json:"hasHasMember,omitempty"`
	HasHasMemberWith []*MemberWhereInput `json:"hasHasMemberWith,omitempty"`

	// "has_flight" edge predicates.
	HasHasFlight     *bool               `json:"hasHasFlight,omitempty"`
	HasHasFlightWith []*FlightWhereInput `json:"hasHasFlightWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CustomerWhereInput) AddPredicates(predicates ...predicate.Customer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CustomerWhereInput filter on the CustomerQuery builder.
func (i *CustomerWhereInput) Filter(q *CustomerQuery) (*CustomerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCustomerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCustomerWhereInput is returned in case the CustomerWhereInput is empty.
var ErrEmptyCustomerWhereInput = errors.New("ent: empty predicate CustomerWhereInput")

// P returns a predicate for filtering customers.
// An error is returned if the input is empty or invalid.
func (i *CustomerWhereInput) P() (predicate.Customer, error) {
	var predicates []predicate.Customer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, customer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Customer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, customer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Customer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, customer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, customer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, customer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, customer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, customer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, customer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, customer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, customer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, customer.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, customer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, customer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, customer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, customer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, customer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, customer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, customer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, customer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, customer.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, customer.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, customer.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, customer.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, customer.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, customer.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, customer.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, customer.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, customer.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, customer.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, customer.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, customer.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, customer.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, customer.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, customer.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, customer.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, customer.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, customer.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, customer.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, customer.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, customer.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, customer.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, customer.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, customer.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, customer.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, customer.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, customer.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, customer.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, customer.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, customer.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, customer.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, customer.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, customer.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, customer.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, customer.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, customer.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, customer.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, customer.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, customer.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, customer.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, customer.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, customer.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, customer.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, customer.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, customer.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, customer.FullNameContainsFold(*i.FullNameContainsFold))
	}
	if i.Dob != nil {
		predicates = append(predicates, customer.DobEQ(*i.Dob))
	}
	if i.DobNEQ != nil {
		predicates = append(predicates, customer.DobNEQ(*i.DobNEQ))
	}
	if len(i.DobIn) > 0 {
		predicates = append(predicates, customer.DobIn(i.DobIn...))
	}
	if len(i.DobNotIn) > 0 {
		predicates = append(predicates, customer.DobNotIn(i.DobNotIn...))
	}
	if i.DobGT != nil {
		predicates = append(predicates, customer.DobGT(*i.DobGT))
	}
	if i.DobGTE != nil {
		predicates = append(predicates, customer.DobGTE(*i.DobGTE))
	}
	if i.DobLT != nil {
		predicates = append(predicates, customer.DobLT(*i.DobLT))
	}
	if i.DobLTE != nil {
		predicates = append(predicates, customer.DobLTE(*i.DobLTE))
	}
	if i.Cid != nil {
		predicates = append(predicates, customer.CidEQ(*i.Cid))
	}
	if i.CidNEQ != nil {
		predicates = append(predicates, customer.CidNEQ(*i.CidNEQ))
	}
	if len(i.CidIn) > 0 {
		predicates = append(predicates, customer.CidIn(i.CidIn...))
	}
	if len(i.CidNotIn) > 0 {
		predicates = append(predicates, customer.CidNotIn(i.CidNotIn...))
	}
	if i.CidGT != nil {
		predicates = append(predicates, customer.CidGT(*i.CidGT))
	}
	if i.CidGTE != nil {
		predicates = append(predicates, customer.CidGTE(*i.CidGTE))
	}
	if i.CidLT != nil {
		predicates = append(predicates, customer.CidLT(*i.CidLT))
	}
	if i.CidLTE != nil {
		predicates = append(predicates, customer.CidLTE(*i.CidLTE))
	}
	if i.CidContains != nil {
		predicates = append(predicates, customer.CidContains(*i.CidContains))
	}
	if i.CidHasPrefix != nil {
		predicates = append(predicates, customer.CidHasPrefix(*i.CidHasPrefix))
	}
	if i.CidHasSuffix != nil {
		predicates = append(predicates, customer.CidHasSuffix(*i.CidHasSuffix))
	}
	if i.CidEqualFold != nil {
		predicates = append(predicates, customer.CidEqualFold(*i.CidEqualFold))
	}
	if i.CidContainsFold != nil {
		predicates = append(predicates, customer.CidContainsFold(*i.CidContainsFold))
	}
	if i.MemberID != nil {
		predicates = append(predicates, customer.MemberIDEQ(*i.MemberID))
	}
	if i.MemberIDNEQ != nil {
		predicates = append(predicates, customer.MemberIDNEQ(*i.MemberIDNEQ))
	}
	if len(i.MemberIDIn) > 0 {
		predicates = append(predicates, customer.MemberIDIn(i.MemberIDIn...))
	}
	if len(i.MemberIDNotIn) > 0 {
		predicates = append(predicates, customer.MemberIDNotIn(i.MemberIDNotIn...))
	}
	if i.MemberIDIsNil {
		predicates = append(predicates, customer.MemberIDIsNil())
	}
	if i.MemberIDNotNil {
		predicates = append(predicates, customer.MemberIDNotNil())
	}

	if i.HasHasMember != nil {
		p := customer.HasHasMember()
		if !*i.HasHasMember {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasMemberWith) > 0 {
		with := make([]predicate.Member, 0, len(i.HasHasMemberWith))
		for _, w := range i.HasHasMemberWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasMemberWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasHasMemberWith(with...))
	}
	if i.HasHasFlight != nil {
		p := customer.HasHasFlight()
		if !*i.HasHasFlight {
			p = customer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasFlightWith) > 0 {
		with := make([]predicate.Flight, 0, len(i.HasHasFlightWith))
		for _, w := range i.HasHasFlightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasFlightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, customer.HasHasFlightWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCustomerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return customer.And(predicates...), nil
	}
}

// FlightWhereInput represents a where input for filtering Flight queries.
type FlightWhereInput struct {
	Predicates []predicate.Flight  `json:"-"`
	Not        *FlightWhereInput   `json:"not,omitempty"`
	Or         []*FlightWhereInput `json:"or,omitempty"`
	And        []*FlightWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "depart_at" field predicates.
	DepartAt      *time.Time  `json:"departAt,omitempty"`
	DepartAtNEQ   *time.Time  `json:"departAtNEQ,omitempty"`
	DepartAtIn    []time.Time `json:"departAtIn,omitempty"`
	DepartAtNotIn []time.Time `json:"departAtNotIn,omitempty"`
	DepartAtGT    *time.Time  `json:"departAtGT,omitempty"`
	DepartAtGTE   *time.Time  `json:"departAtGTE,omitempty"`
	DepartAtLT    *time.Time  `json:"departAtLT,omitempty"`
	DepartAtLTE   *time.Time  `json:"departAtLTE,omitempty"`

	// "land_at" field predicates.
	LandAt      *time.Time  `json:"landAt,omitempty"`
	LandAtNEQ   *time.Time  `json:"landAtNEQ,omitempty"`
	LandAtIn    []time.Time `json:"landAtIn,omitempty"`
	LandAtNotIn []time.Time `json:"landAtNotIn,omitempty"`
	LandAtGT    *time.Time  `json:"landAtGT,omitempty"`
	LandAtGTE   *time.Time  `json:"landAtGTE,omitempty"`
	LandAtLT    *time.Time  `json:"landAtLT,omitempty"`
	LandAtLTE   *time.Time  `json:"landAtLTE,omitempty"`

	// "available_ec_slot" field predicates.
	AvailableEcSlot      *int  `json:"availableEcSlot,omitempty"`
	AvailableEcSlotNEQ   *int  `json:"availableEcSlotNEQ,omitempty"`
	AvailableEcSlotIn    []int `json:"availableEcSlotIn,omitempty"`
	AvailableEcSlotNotIn []int `json:"availableEcSlotNotIn,omitempty"`
	AvailableEcSlotGT    *int  `json:"availableEcSlotGT,omitempty"`
	AvailableEcSlotGTE   *int  `json:"availableEcSlotGTE,omitempty"`
	AvailableEcSlotLT    *int  `json:"availableEcSlotLT,omitempty"`
	AvailableEcSlotLTE   *int  `json:"availableEcSlotLTE,omitempty"`

	// "available_bc_slot" field predicates.
	AvailableBcSlot      *int  `json:"availableBcSlot,omitempty"`
	AvailableBcSlotNEQ   *int  `json:"availableBcSlotNEQ,omitempty"`
	AvailableBcSlotIn    []int `json:"availableBcSlotIn,omitempty"`
	AvailableBcSlotNotIn []int `json:"availableBcSlotNotIn,omitempty"`
	AvailableBcSlotGT    *int  `json:"availableBcSlotGT,omitempty"`
	AvailableBcSlotGTE   *int  `json:"availableBcSlotGTE,omitempty"`
	AvailableBcSlotLT    *int  `json:"availableBcSlotLT,omitempty"`
	AvailableBcSlotLTE   *int  `json:"availableBcSlotLTE,omitempty"`

	// "status" field predicates.
	Status      *flight.Status  `json:"status,omitempty"`
	StatusNEQ   *flight.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []flight.Status `json:"statusIn,omitempty"`
	StatusNotIn []flight.Status `json:"statusNotIn,omitempty"`

	// "plane_id" field predicates.
	PlaneID       *int  `json:"planeID,omitempty"`
	PlaneIDNEQ    *int  `json:"planeIDNEQ,omitempty"`
	PlaneIDIn     []int `json:"planeIDIn,omitempty"`
	PlaneIDNotIn  []int `json:"planeIDNotIn,omitempty"`
	PlaneIDIsNil  bool  `json:"planeIDIsNil,omitempty"`
	PlaneIDNotNil bool  `json:"planeIDNotNil,omitempty"`

	// "airport_id" field predicates.
	AirportID       *int  `json:"airportID,omitempty"`
	AirportIDNEQ    *int  `json:"airportIDNEQ,omitempty"`
	AirportIDIn     []int `json:"airportIDIn,omitempty"`
	AirportIDNotIn  []int `json:"airportIDNotIn,omitempty"`
	AirportIDIsNil  bool  `json:"airportIDIsNil,omitempty"`
	AirportIDNotNil bool  `json:"airportIDNotNil,omitempty"`

	// "customer_id" field predicates.
	CustomerID       *int  `json:"customerID,omitempty"`
	CustomerIDNEQ    *int  `json:"customerIDNEQ,omitempty"`
	CustomerIDIn     []int `json:"customerIDIn,omitempty"`
	CustomerIDNotIn  []int `json:"customerIDNotIn,omitempty"`
	CustomerIDIsNil  bool  `json:"customerIDIsNil,omitempty"`
	CustomerIDNotNil bool  `json:"customerIDNotNil,omitempty"`

	// "has_plane" edge predicates.
	HasHasPlane     *bool              `json:"hasHasPlane,omitempty"`
	HasHasPlaneWith []*PlaneWhereInput `json:"hasHasPlaneWith,omitempty"`

	// "has_booking" edge predicates.
	HasHasBooking     *bool                `json:"hasHasBooking,omitempty"`
	HasHasBookingWith []*BookingWhereInput `json:"hasHasBookingWith,omitempty"`

	// "has_airport" edge predicates.
	HasHasAirport     *bool                `json:"hasHasAirport,omitempty"`
	HasHasAirportWith []*AirportWhereInput `json:"hasHasAirportWith,omitempty"`

	// "has_customer" edge predicates.
	HasHasCustomer     *bool                 `json:"hasHasCustomer,omitempty"`
	HasHasCustomerWith []*CustomerWhereInput `json:"hasHasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *FlightWhereInput) AddPredicates(predicates ...predicate.Flight) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the FlightWhereInput filter on the FlightQuery builder.
func (i *FlightWhereInput) Filter(q *FlightQuery) (*FlightQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyFlightWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyFlightWhereInput is returned in case the FlightWhereInput is empty.
var ErrEmptyFlightWhereInput = errors.New("ent: empty predicate FlightWhereInput")

// P returns a predicate for filtering flights.
// An error is returned if the input is empty or invalid.
func (i *FlightWhereInput) P() (predicate.Flight, error) {
	var predicates []predicate.Flight
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, flight.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Flight, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, flight.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Flight, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, flight.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, flight.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, flight.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, flight.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, flight.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, flight.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, flight.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, flight.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, flight.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, flight.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, flight.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, flight.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, flight.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, flight.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, flight.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, flight.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, flight.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, flight.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, flight.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, flight.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, flight.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, flight.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, flight.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, flight.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, flight.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, flight.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, flight.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, flight.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, flight.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, flight.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, flight.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, flight.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, flight.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, flight.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, flight.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, flight.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, flight.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, flight.NameContainsFold(*i.NameContainsFold))
	}
	if i.DepartAt != nil {
		predicates = append(predicates, flight.DepartAtEQ(*i.DepartAt))
	}
	if i.DepartAtNEQ != nil {
		predicates = append(predicates, flight.DepartAtNEQ(*i.DepartAtNEQ))
	}
	if len(i.DepartAtIn) > 0 {
		predicates = append(predicates, flight.DepartAtIn(i.DepartAtIn...))
	}
	if len(i.DepartAtNotIn) > 0 {
		predicates = append(predicates, flight.DepartAtNotIn(i.DepartAtNotIn...))
	}
	if i.DepartAtGT != nil {
		predicates = append(predicates, flight.DepartAtGT(*i.DepartAtGT))
	}
	if i.DepartAtGTE != nil {
		predicates = append(predicates, flight.DepartAtGTE(*i.DepartAtGTE))
	}
	if i.DepartAtLT != nil {
		predicates = append(predicates, flight.DepartAtLT(*i.DepartAtLT))
	}
	if i.DepartAtLTE != nil {
		predicates = append(predicates, flight.DepartAtLTE(*i.DepartAtLTE))
	}
	if i.LandAt != nil {
		predicates = append(predicates, flight.LandAtEQ(*i.LandAt))
	}
	if i.LandAtNEQ != nil {
		predicates = append(predicates, flight.LandAtNEQ(*i.LandAtNEQ))
	}
	if len(i.LandAtIn) > 0 {
		predicates = append(predicates, flight.LandAtIn(i.LandAtIn...))
	}
	if len(i.LandAtNotIn) > 0 {
		predicates = append(predicates, flight.LandAtNotIn(i.LandAtNotIn...))
	}
	if i.LandAtGT != nil {
		predicates = append(predicates, flight.LandAtGT(*i.LandAtGT))
	}
	if i.LandAtGTE != nil {
		predicates = append(predicates, flight.LandAtGTE(*i.LandAtGTE))
	}
	if i.LandAtLT != nil {
		predicates = append(predicates, flight.LandAtLT(*i.LandAtLT))
	}
	if i.LandAtLTE != nil {
		predicates = append(predicates, flight.LandAtLTE(*i.LandAtLTE))
	}
	if i.AvailableEcSlot != nil {
		predicates = append(predicates, flight.AvailableEcSlotEQ(*i.AvailableEcSlot))
	}
	if i.AvailableEcSlotNEQ != nil {
		predicates = append(predicates, flight.AvailableEcSlotNEQ(*i.AvailableEcSlotNEQ))
	}
	if len(i.AvailableEcSlotIn) > 0 {
		predicates = append(predicates, flight.AvailableEcSlotIn(i.AvailableEcSlotIn...))
	}
	if len(i.AvailableEcSlotNotIn) > 0 {
		predicates = append(predicates, flight.AvailableEcSlotNotIn(i.AvailableEcSlotNotIn...))
	}
	if i.AvailableEcSlotGT != nil {
		predicates = append(predicates, flight.AvailableEcSlotGT(*i.AvailableEcSlotGT))
	}
	if i.AvailableEcSlotGTE != nil {
		predicates = append(predicates, flight.AvailableEcSlotGTE(*i.AvailableEcSlotGTE))
	}
	if i.AvailableEcSlotLT != nil {
		predicates = append(predicates, flight.AvailableEcSlotLT(*i.AvailableEcSlotLT))
	}
	if i.AvailableEcSlotLTE != nil {
		predicates = append(predicates, flight.AvailableEcSlotLTE(*i.AvailableEcSlotLTE))
	}
	if i.AvailableBcSlot != nil {
		predicates = append(predicates, flight.AvailableBcSlotEQ(*i.AvailableBcSlot))
	}
	if i.AvailableBcSlotNEQ != nil {
		predicates = append(predicates, flight.AvailableBcSlotNEQ(*i.AvailableBcSlotNEQ))
	}
	if len(i.AvailableBcSlotIn) > 0 {
		predicates = append(predicates, flight.AvailableBcSlotIn(i.AvailableBcSlotIn...))
	}
	if len(i.AvailableBcSlotNotIn) > 0 {
		predicates = append(predicates, flight.AvailableBcSlotNotIn(i.AvailableBcSlotNotIn...))
	}
	if i.AvailableBcSlotGT != nil {
		predicates = append(predicates, flight.AvailableBcSlotGT(*i.AvailableBcSlotGT))
	}
	if i.AvailableBcSlotGTE != nil {
		predicates = append(predicates, flight.AvailableBcSlotGTE(*i.AvailableBcSlotGTE))
	}
	if i.AvailableBcSlotLT != nil {
		predicates = append(predicates, flight.AvailableBcSlotLT(*i.AvailableBcSlotLT))
	}
	if i.AvailableBcSlotLTE != nil {
		predicates = append(predicates, flight.AvailableBcSlotLTE(*i.AvailableBcSlotLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, flight.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, flight.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, flight.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, flight.StatusNotIn(i.StatusNotIn...))
	}
	if i.PlaneID != nil {
		predicates = append(predicates, flight.PlaneIDEQ(*i.PlaneID))
	}
	if i.PlaneIDNEQ != nil {
		predicates = append(predicates, flight.PlaneIDNEQ(*i.PlaneIDNEQ))
	}
	if len(i.PlaneIDIn) > 0 {
		predicates = append(predicates, flight.PlaneIDIn(i.PlaneIDIn...))
	}
	if len(i.PlaneIDNotIn) > 0 {
		predicates = append(predicates, flight.PlaneIDNotIn(i.PlaneIDNotIn...))
	}
	if i.PlaneIDIsNil {
		predicates = append(predicates, flight.PlaneIDIsNil())
	}
	if i.PlaneIDNotNil {
		predicates = append(predicates, flight.PlaneIDNotNil())
	}
	if i.AirportID != nil {
		predicates = append(predicates, flight.AirportIDEQ(*i.AirportID))
	}
	if i.AirportIDNEQ != nil {
		predicates = append(predicates, flight.AirportIDNEQ(*i.AirportIDNEQ))
	}
	if len(i.AirportIDIn) > 0 {
		predicates = append(predicates, flight.AirportIDIn(i.AirportIDIn...))
	}
	if len(i.AirportIDNotIn) > 0 {
		predicates = append(predicates, flight.AirportIDNotIn(i.AirportIDNotIn...))
	}
	if i.AirportIDIsNil {
		predicates = append(predicates, flight.AirportIDIsNil())
	}
	if i.AirportIDNotNil {
		predicates = append(predicates, flight.AirportIDNotNil())
	}
	if i.CustomerID != nil {
		predicates = append(predicates, flight.CustomerIDEQ(*i.CustomerID))
	}
	if i.CustomerIDNEQ != nil {
		predicates = append(predicates, flight.CustomerIDNEQ(*i.CustomerIDNEQ))
	}
	if len(i.CustomerIDIn) > 0 {
		predicates = append(predicates, flight.CustomerIDIn(i.CustomerIDIn...))
	}
	if len(i.CustomerIDNotIn) > 0 {
		predicates = append(predicates, flight.CustomerIDNotIn(i.CustomerIDNotIn...))
	}
	if i.CustomerIDIsNil {
		predicates = append(predicates, flight.CustomerIDIsNil())
	}
	if i.CustomerIDNotNil {
		predicates = append(predicates, flight.CustomerIDNotNil())
	}

	if i.HasHasPlane != nil {
		p := flight.HasHasPlane()
		if !*i.HasHasPlane {
			p = flight.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasPlaneWith) > 0 {
		with := make([]predicate.Plane, 0, len(i.HasHasPlaneWith))
		for _, w := range i.HasHasPlaneWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasPlaneWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, flight.HasHasPlaneWith(with...))
	}
	if i.HasHasBooking != nil {
		p := flight.HasHasBooking()
		if !*i.HasHasBooking {
			p = flight.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasBookingWith) > 0 {
		with := make([]predicate.Booking, 0, len(i.HasHasBookingWith))
		for _, w := range i.HasHasBookingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasBookingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, flight.HasHasBookingWith(with...))
	}
	if i.HasHasAirport != nil {
		p := flight.HasHasAirport()
		if !*i.HasHasAirport {
			p = flight.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasAirportWith) > 0 {
		with := make([]predicate.Airport, 0, len(i.HasHasAirportWith))
		for _, w := range i.HasHasAirportWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasAirportWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, flight.HasHasAirportWith(with...))
	}
	if i.HasHasCustomer != nil {
		p := flight.HasHasCustomer()
		if !*i.HasHasCustomer {
			p = flight.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasHasCustomerWith))
		for _, w := range i.HasHasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, flight.HasHasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyFlightWhereInput
	case 1:
		return predicates[0], nil
	default:
		return flight.And(predicates...), nil
	}
}

// MemberWhereInput represents a where input for filtering Member queries.
type MemberWhereInput struct {
	Predicates []predicate.Member  `json:"-"`
	Not        *MemberWhereInput   `json:"not,omitempty"`
	Or         []*MemberWhereInput `json:"or,omitempty"`
	And        []*MemberWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "full_name" field predicates.
	FullName             *string  `json:"fullName,omitempty"`
	FullNameNEQ          *string  `json:"fullNameNEQ,omitempty"`
	FullNameIn           []string `json:"fullNameIn,omitempty"`
	FullNameNotIn        []string `json:"fullNameNotIn,omitempty"`
	FullNameGT           *string  `json:"fullNameGT,omitempty"`
	FullNameGTE          *string  `json:"fullNameGTE,omitempty"`
	FullNameLT           *string  `json:"fullNameLT,omitempty"`
	FullNameLTE          *string  `json:"fullNameLTE,omitempty"`
	FullNameContains     *string  `json:"fullNameContains,omitempty"`
	FullNameHasPrefix    *string  `json:"fullNameHasPrefix,omitempty"`
	FullNameHasSuffix    *string  `json:"fullNameHasSuffix,omitempty"`
	FullNameEqualFold    *string  `json:"fullNameEqualFold,omitempty"`
	FullNameContainsFold *string  `json:"fullNameContainsFold,omitempty"`

	// "dob" field predicates.
	Dob       *time.Time  `json:"dob,omitempty"`
	DobNEQ    *time.Time  `json:"dobNEQ,omitempty"`
	DobIn     []time.Time `json:"dobIn,omitempty"`
	DobNotIn  []time.Time `json:"dobNotIn,omitempty"`
	DobGT     *time.Time  `json:"dobGT,omitempty"`
	DobGTE    *time.Time  `json:"dobGTE,omitempty"`
	DobLT     *time.Time  `json:"dobLT,omitempty"`
	DobLTE    *time.Time  `json:"dobLTE,omitempty"`
	DobIsNil  bool        `json:"dobIsNil,omitempty"`
	DobNotNil bool        `json:"dobNotNil,omitempty"`

	// "cid" field predicates.
	Cid             *string  `json:"cid,omitempty"`
	CidNEQ          *string  `json:"cidNEQ,omitempty"`
	CidIn           []string `json:"cidIn,omitempty"`
	CidNotIn        []string `json:"cidNotIn,omitempty"`
	CidGT           *string  `json:"cidGT,omitempty"`
	CidGTE          *string  `json:"cidGTE,omitempty"`
	CidLT           *string  `json:"cidLT,omitempty"`
	CidLTE          *string  `json:"cidLTE,omitempty"`
	CidContains     *string  `json:"cidContains,omitempty"`
	CidHasPrefix    *string  `json:"cidHasPrefix,omitempty"`
	CidHasSuffix    *string  `json:"cidHasSuffix,omitempty"`
	CidEqualFold    *string  `json:"cidEqualFold,omitempty"`
	CidContainsFold *string  `json:"cidContainsFold,omitempty"`

	// "role" field predicates.
	Role      *int  `json:"role,omitempty"`
	RoleNEQ   *int  `json:"roleNEQ,omitempty"`
	RoleIn    []int `json:"roleIn,omitempty"`
	RoleNotIn []int `json:"roleNotIn,omitempty"`
	RoleGT    *int  `json:"roleGT,omitempty"`
	RoleGTE   *int  `json:"roleGTE,omitempty"`
	RoleLT    *int  `json:"roleLT,omitempty"`
	RoleLTE   *int  `json:"roleLTE,omitempty"`

	// "has_customer" edge predicates.
	HasHasCustomer     *bool                 `json:"hasHasCustomer,omitempty"`
	HasHasCustomerWith []*CustomerWhereInput `json:"hasHasCustomerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *MemberWhereInput) AddPredicates(predicates ...predicate.Member) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the MemberWhereInput filter on the MemberQuery builder.
func (i *MemberWhereInput) Filter(q *MemberQuery) (*MemberQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyMemberWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyMemberWhereInput is returned in case the MemberWhereInput is empty.
var ErrEmptyMemberWhereInput = errors.New("ent: empty predicate MemberWhereInput")

// P returns a predicate for filtering members.
// An error is returned if the input is empty or invalid.
func (i *MemberWhereInput) P() (predicate.Member, error) {
	var predicates []predicate.Member
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, member.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Member, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, member.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Member, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, member.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, member.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, member.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, member.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, member.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, member.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, member.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, member.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, member.IDLTE(*i.IDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, member.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, member.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, member.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, member.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, member.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, member.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, member.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, member.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, member.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, member.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, member.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, member.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, member.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, member.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, member.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, member.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Email != nil {
		predicates = append(predicates, member.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, member.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, member.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, member.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, member.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, member.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, member.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, member.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, member.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, member.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, member.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, member.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, member.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, member.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, member.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, member.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, member.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, member.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, member.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, member.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, member.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, member.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, member.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, member.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, member.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, member.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, member.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, member.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, member.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, member.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, member.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, member.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, member.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, member.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, member.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, member.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, member.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, member.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, member.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.FullName != nil {
		predicates = append(predicates, member.FullNameEQ(*i.FullName))
	}
	if i.FullNameNEQ != nil {
		predicates = append(predicates, member.FullNameNEQ(*i.FullNameNEQ))
	}
	if len(i.FullNameIn) > 0 {
		predicates = append(predicates, member.FullNameIn(i.FullNameIn...))
	}
	if len(i.FullNameNotIn) > 0 {
		predicates = append(predicates, member.FullNameNotIn(i.FullNameNotIn...))
	}
	if i.FullNameGT != nil {
		predicates = append(predicates, member.FullNameGT(*i.FullNameGT))
	}
	if i.FullNameGTE != nil {
		predicates = append(predicates, member.FullNameGTE(*i.FullNameGTE))
	}
	if i.FullNameLT != nil {
		predicates = append(predicates, member.FullNameLT(*i.FullNameLT))
	}
	if i.FullNameLTE != nil {
		predicates = append(predicates, member.FullNameLTE(*i.FullNameLTE))
	}
	if i.FullNameContains != nil {
		predicates = append(predicates, member.FullNameContains(*i.FullNameContains))
	}
	if i.FullNameHasPrefix != nil {
		predicates = append(predicates, member.FullNameHasPrefix(*i.FullNameHasPrefix))
	}
	if i.FullNameHasSuffix != nil {
		predicates = append(predicates, member.FullNameHasSuffix(*i.FullNameHasSuffix))
	}
	if i.FullNameEqualFold != nil {
		predicates = append(predicates, member.FullNameEqualFold(*i.FullNameEqualFold))
	}
	if i.FullNameContainsFold != nil {
		predicates = append(predicates, member.FullNameContainsFold(*i.FullNameContainsFold))
	}
	if i.Dob != nil {
		predicates = append(predicates, member.DobEQ(*i.Dob))
	}
	if i.DobNEQ != nil {
		predicates = append(predicates, member.DobNEQ(*i.DobNEQ))
	}
	if len(i.DobIn) > 0 {
		predicates = append(predicates, member.DobIn(i.DobIn...))
	}
	if len(i.DobNotIn) > 0 {
		predicates = append(predicates, member.DobNotIn(i.DobNotIn...))
	}
	if i.DobGT != nil {
		predicates = append(predicates, member.DobGT(*i.DobGT))
	}
	if i.DobGTE != nil {
		predicates = append(predicates, member.DobGTE(*i.DobGTE))
	}
	if i.DobLT != nil {
		predicates = append(predicates, member.DobLT(*i.DobLT))
	}
	if i.DobLTE != nil {
		predicates = append(predicates, member.DobLTE(*i.DobLTE))
	}
	if i.DobIsNil {
		predicates = append(predicates, member.DobIsNil())
	}
	if i.DobNotNil {
		predicates = append(predicates, member.DobNotNil())
	}
	if i.Cid != nil {
		predicates = append(predicates, member.CidEQ(*i.Cid))
	}
	if i.CidNEQ != nil {
		predicates = append(predicates, member.CidNEQ(*i.CidNEQ))
	}
	if len(i.CidIn) > 0 {
		predicates = append(predicates, member.CidIn(i.CidIn...))
	}
	if len(i.CidNotIn) > 0 {
		predicates = append(predicates, member.CidNotIn(i.CidNotIn...))
	}
	if i.CidGT != nil {
		predicates = append(predicates, member.CidGT(*i.CidGT))
	}
	if i.CidGTE != nil {
		predicates = append(predicates, member.CidGTE(*i.CidGTE))
	}
	if i.CidLT != nil {
		predicates = append(predicates, member.CidLT(*i.CidLT))
	}
	if i.CidLTE != nil {
		predicates = append(predicates, member.CidLTE(*i.CidLTE))
	}
	if i.CidContains != nil {
		predicates = append(predicates, member.CidContains(*i.CidContains))
	}
	if i.CidHasPrefix != nil {
		predicates = append(predicates, member.CidHasPrefix(*i.CidHasPrefix))
	}
	if i.CidHasSuffix != nil {
		predicates = append(predicates, member.CidHasSuffix(*i.CidHasSuffix))
	}
	if i.CidEqualFold != nil {
		predicates = append(predicates, member.CidEqualFold(*i.CidEqualFold))
	}
	if i.CidContainsFold != nil {
		predicates = append(predicates, member.CidContainsFold(*i.CidContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, member.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, member.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, member.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, member.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleGT != nil {
		predicates = append(predicates, member.RoleGT(*i.RoleGT))
	}
	if i.RoleGTE != nil {
		predicates = append(predicates, member.RoleGTE(*i.RoleGTE))
	}
	if i.RoleLT != nil {
		predicates = append(predicates, member.RoleLT(*i.RoleLT))
	}
	if i.RoleLTE != nil {
		predicates = append(predicates, member.RoleLTE(*i.RoleLTE))
	}

	if i.HasHasCustomer != nil {
		p := member.HasHasCustomer()
		if !*i.HasHasCustomer {
			p = member.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHasCustomerWith) > 0 {
		with := make([]predicate.Customer, 0, len(i.HasHasCustomerWith))
		for _, w := range i.HasHasCustomerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHasCustomerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, member.HasHasCustomerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyMemberWhereInput
	case 1:
		return predicates[0], nil
	default:
		return member.And(predicates...), nil
	}
}

// PlaneWhereInput represents a where input for filtering Plane queries.
type PlaneWhereInput struct {
	Predicates []predicate.Plane  `json:"-"`
	Not        *PlaneWhereInput   `json:"not,omitempty"`
	Or         []*PlaneWhereInput `json:"or,omitempty"`
	And        []*PlaneWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *int  `json:"id,omitempty"`
	IDNEQ   *int  `json:"idNEQ,omitempty"`
	IDIn    []int `json:"idIn,omitempty"`
	IDNotIn []int `json:"idNotIn,omitempty"`
	IDGT    *int  `json:"idGT,omitempty"`
	IDGTE   *int  `json:"idGTE,omitempty"`
	IDLT    *int  `json:"idLT,omitempty"`
	IDLTE   *int  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "economy_class_slots" field predicates.
	EconomyClassSlots      *int64  `json:"economyClassSlots,omitempty"`
	EconomyClassSlotsNEQ   *int64  `json:"economyClassSlotsNEQ,omitempty"`
	EconomyClassSlotsIn    []int64 `json:"economyClassSlotsIn,omitempty"`
	EconomyClassSlotsNotIn []int64 `json:"economyClassSlotsNotIn,omitempty"`
	EconomyClassSlotsGT    *int64  `json:"economyClassSlotsGT,omitempty"`
	EconomyClassSlotsGTE   *int64  `json:"economyClassSlotsGTE,omitempty"`
	EconomyClassSlotsLT    *int64  `json:"economyClassSlotsLT,omitempty"`
	EconomyClassSlotsLTE   *int64  `json:"economyClassSlotsLTE,omitempty"`

	// "business_class_slots" field predicates.
	BusinessClassSlots      *int64  `json:"businessClassSlots,omitempty"`
	BusinessClassSlotsNEQ   *int64  `json:"businessClassSlotsNEQ,omitempty"`
	BusinessClassSlotsIn    []int64 `json:"businessClassSlotsIn,omitempty"`
	BusinessClassSlotsNotIn []int64 `json:"businessClassSlotsNotIn,omitempty"`
	BusinessClassSlotsGT    *int64  `json:"businessClassSlotsGT,omitempty"`
	BusinessClassSlotsGTE   *int64  `json:"businessClassSlotsGTE,omitempty"`
	BusinessClassSlotsLT    *int64  `json:"businessClassSlotsLT,omitempty"`
	BusinessClassSlotsLTE   *int64  `json:"businessClassSlotsLTE,omitempty"`

	// "status" field predicates.
	Status      *plane.Status  `json:"status,omitempty"`
	StatusNEQ   *plane.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []plane.Status `json:"statusIn,omitempty"`
	StatusNotIn []plane.Status `json:"statusNotIn,omitempty"`

	// "flights" edge predicates.
	HasFlights     *bool               `json:"hasFlights,omitempty"`
	HasFlightsWith []*FlightWhereInput `json:"hasFlightsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlaneWhereInput) AddPredicates(predicates ...predicate.Plane) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlaneWhereInput filter on the PlaneQuery builder.
func (i *PlaneWhereInput) Filter(q *PlaneQuery) (*PlaneQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlaneWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlaneWhereInput is returned in case the PlaneWhereInput is empty.
var ErrEmptyPlaneWhereInput = errors.New("ent: empty predicate PlaneWhereInput")

// P returns a predicate for filtering planes.
// An error is returned if the input is empty or invalid.
func (i *PlaneWhereInput) P() (predicate.Plane, error) {
	var predicates []predicate.Plane
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, plane.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Plane, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, plane.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Plane, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, plane.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, plane.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plane.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plane.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plane.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plane.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plane.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plane.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plane.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, plane.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, plane.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, plane.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, plane.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, plane.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, plane.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, plane.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, plane.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, plane.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, plane.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, plane.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, plane.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, plane.NameContainsFold(*i.NameContainsFold))
	}
	if i.EconomyClassSlots != nil {
		predicates = append(predicates, plane.EconomyClassSlotsEQ(*i.EconomyClassSlots))
	}
	if i.EconomyClassSlotsNEQ != nil {
		predicates = append(predicates, plane.EconomyClassSlotsNEQ(*i.EconomyClassSlotsNEQ))
	}
	if len(i.EconomyClassSlotsIn) > 0 {
		predicates = append(predicates, plane.EconomyClassSlotsIn(i.EconomyClassSlotsIn...))
	}
	if len(i.EconomyClassSlotsNotIn) > 0 {
		predicates = append(predicates, plane.EconomyClassSlotsNotIn(i.EconomyClassSlotsNotIn...))
	}
	if i.EconomyClassSlotsGT != nil {
		predicates = append(predicates, plane.EconomyClassSlotsGT(*i.EconomyClassSlotsGT))
	}
	if i.EconomyClassSlotsGTE != nil {
		predicates = append(predicates, plane.EconomyClassSlotsGTE(*i.EconomyClassSlotsGTE))
	}
	if i.EconomyClassSlotsLT != nil {
		predicates = append(predicates, plane.EconomyClassSlotsLT(*i.EconomyClassSlotsLT))
	}
	if i.EconomyClassSlotsLTE != nil {
		predicates = append(predicates, plane.EconomyClassSlotsLTE(*i.EconomyClassSlotsLTE))
	}
	if i.BusinessClassSlots != nil {
		predicates = append(predicates, plane.BusinessClassSlotsEQ(*i.BusinessClassSlots))
	}
	if i.BusinessClassSlotsNEQ != nil {
		predicates = append(predicates, plane.BusinessClassSlotsNEQ(*i.BusinessClassSlotsNEQ))
	}
	if len(i.BusinessClassSlotsIn) > 0 {
		predicates = append(predicates, plane.BusinessClassSlotsIn(i.BusinessClassSlotsIn...))
	}
	if len(i.BusinessClassSlotsNotIn) > 0 {
		predicates = append(predicates, plane.BusinessClassSlotsNotIn(i.BusinessClassSlotsNotIn...))
	}
	if i.BusinessClassSlotsGT != nil {
		predicates = append(predicates, plane.BusinessClassSlotsGT(*i.BusinessClassSlotsGT))
	}
	if i.BusinessClassSlotsGTE != nil {
		predicates = append(predicates, plane.BusinessClassSlotsGTE(*i.BusinessClassSlotsGTE))
	}
	if i.BusinessClassSlotsLT != nil {
		predicates = append(predicates, plane.BusinessClassSlotsLT(*i.BusinessClassSlotsLT))
	}
	if i.BusinessClassSlotsLTE != nil {
		predicates = append(predicates, plane.BusinessClassSlotsLTE(*i.BusinessClassSlotsLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, plane.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, plane.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, plane.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, plane.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasFlights != nil {
		p := plane.HasFlights()
		if !*i.HasFlights {
			p = plane.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFlightsWith) > 0 {
		with := make([]predicate.Flight, 0, len(i.HasFlightsWith))
		for _, w := range i.HasFlightsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFlightsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plane.HasFlightsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlaneWhereInput
	case 1:
		return predicates[0], nil
	default:
		return plane.And(predicates...), nil
	}
}
